<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Arch Linux 配置Bluetooth</title>
    <url>/ipfs/arch-linux-pei-zhi-bluetooth/</url>
    <content><![CDATA[<blockquote>
<p>蓝牙是一个短距离无线通信标准，适用于手机、计算机和其他电子设备之间的通信。在 Linux 中，通常使用的蓝牙协议栈实现是 BlueZ.</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>为了使用蓝牙(Blutooth)，必须要安装官方仓库中的 bluez 软件包。</p>
<pre><code>$ sudo pacman -S  bluez bluez-utils </code></pre><p>bluez会使用dbus 服务读取设置和进行pin(个人识别码 personal identification number)配对。蓝牙(Bluetooth)协议需要bluetooth服务来支撑：</p>
<pre><code>$ sudo systemctl enable bluetooth.service
$ sudo systemctl start bluetooth.service</code></pre><p>加载通用蓝牙驱动程序，如果还没有装载：</p>
<pre><code>$ modprobe btusb</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="bluetoothctl"><a href="#bluetoothctl" class="headerlink" title="bluetoothctl"></a>bluetoothctl</h3><p>使用bluetoothctl 需要安装bluez-utils 包。这个在上一步里已经执行过了，这里就直接说配置与使用的方法：</p>
<pre><code>$ bluetoothctl </code></pre><p>help 列出帮助文档。<br><img data-src="/content/images/2015/08/--_2015-08-19_15-31-47.png" alt=""></p>
<ul>
<li>首先执行 <code>power on</code> 打开蓝牙适配器的电源开关，这样蓝牙的LED灯会亮起(默认是关闭的)。</li>
<li>先用命令 <code>devices</code> 列出有已匹配的设备MAC地址</li>
<li>如果列表为空，那么就要使用 <code>scan on</code> 来扫描网络中开启蓝牙的设备</li>
<li>开启代理 <code>agent on</code></li>
<li>输入命令 <code>pair [MAC Address]</code> 匹配两个蓝牙设备</li>
<li>如果使用设备没有PIN，要成功地重新连接设备之前，可能需要手动信任设备。输入 <code>trust [MAC Address]</code> </li>
<li>如果以上步骤都没有问题的话，那么就可以链接你的蓝牙设备了。 <code>connect [MAC Address]</code></li>
</ul>
<h3 id="Obex"><a href="#Obex" class="headerlink" title="Obex"></a>Obex</h3><p>使用obexctl是在蓝牙设备之间发送和接收文件的工具，是随bluez包安装好了的,在终端直接输入 <code>obexctl</code> 就可以进入obex环境，如图：<br><img data-src="/content/images/2015/08/--_2015-08-19_16-41-12.png" alt=""></p>
<p>另外还有一个命令行工具obexfs (包括obexfs,obexftp等)</p>
<pre><code>$ sudo pacman -S obexfs</code></pre><p>安装好了就可以使用命令直接挂载蓝牙设备到本地目录，</p>
<pre><code>$ obexfs -b MAC_address_of_device -p /mnt/bluez/</code></pre><p>一旦你完成了，卸载的设备使用以下命令：</p>
<pre><code>$ fusermount -u /mnt/bluez/</code></pre><p>如果您的设备支持FTP服务，但你不希望加载该设备，您可以使用obexftp传输文件在设备之间。<br>发送文件：</p>
<pre><code>$ obexftp -b MAC_address_of_device -p /path/to/file</code></pre><p>接收文件：</p>
<pre><code>$ obexftp -b MAC_address_of_device -g filename</code></pre><h3 id="Bluetooth-USB-适配器"><a href="#Bluetooth-USB-适配器" class="headerlink" title="Bluetooth USB 适配器"></a>Bluetooth USB 适配器</h3><p>如果你在使用USB适配器，你应当确认你的适配器被正确识别。你可以在插入适配器时通过查看/var/log/messages.log （或者journalctl -f)，</p>
<pre><code>$ tail -f /var/log/messages.log</code></pre><p>这应当会出现类似于下面所示的信息：</p>
<p>May  2 23:36:40 tatooine usb 4-1: new full speed USB device using uhci_hcd and address 9<br>May  2 23:36:40 tatooine usb 4-1: configuration #1 chosen from 1 choice<br>May  2 23:36:41 tatooine hcid[8109]: HCI dev 0 registered<br>May  2 23:36:41 tatooine hcid[8109]: HCI dev 0 up<br>May  2 23:36:41 tatooine hcid[8109]: Device hci0 has been added<br>May  2 23:36:41 tatooine hcid[8109]: Starting security manager 0<br>May  2 23:36:41 tatooine hcid[8109]: Device hci0 has been activated</p>
<p>如果你只得到了前面两行，说明了电脑发现了这个设备，但是你需要手动启动它。 例如：</p>
<pre><code>$ hciconfig -a hci0
$ hciconfig hci0 up</code></pre><p>如果不能从你的手机发现电脑，那么就需要启用PSCAN和ISCAN：</p>
<pre><code>$ hciconfig hci0 piscan </code></pre><p>注意: 检查/etc/bluetooth/main.conf中的发现倒计时和配对倒计时<br>试着在 /etc/bluetooth/main.conf 改变设备的class<br><img data-src="/content/images/2015/08/--_2015-08-19_17-23-20.png" alt=""><br>修改：Class = 0x100100</p>
<p>==参考：<a href="https://wiki.archlinux.org/index.php/Bluetooth" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Bluetooth</a> ==</p>
]]></content>
      <tags>
        <tag>archlinux</tag>
        <tag>bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title>10个很有用的 Git 命令（转）</title>
    <url>/ipfs/10ge-hen-you-yong-de-git-ming-ling-zhuan/</url>
    <content><![CDATA[<p><a href="http://blog.sae.sina.com.cn/archives/3003" target="_blank" rel="noopener">转自</a><a href="http://blog.sae.sina.com.cn/archives/3003" target="_blank" rel="noopener">http://blog.sae.sina.com.cn/archives/3003</a></p>
<blockquote>
<p>这里给大家分享一些很有用的 Git 命令，其中很多用法你可能都不知道，无论你是工作在团队环境中或在您的个人项目中，这些命令将对你帮助很大，让你可以更加高效的进行项目开发，更轻松愉快的工作和生活。</p>
</blockquote>
<h3 id="导出最后一次提交修改过的文件"><a href="#导出最后一次提交修改过的文件" class="headerlink" title="导出最后一次提交修改过的文件"></a>导出最后一次提交修改过的文件</h3><p>我一直在使用这个命令定期进行发送给其他人进行审查/整合。这条命令将把近期提交的修改过的文件导出到一个zip文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git archive -o ..&#x2F;updated.zip HEAD $(git diff --name-only HEAD^)</span><br></pre></td></tr></table></figure>
<h3 id="导出两次提交之间修改过的文件"><a href="#导出两次提交之间修改过的文件" class="headerlink" title="导出两次提交之间修改过的文件"></a>导出两次提交之间修改过的文件</h3><p>同样，如果你需要导出两次提交之间修改过的文件，你可以用这一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git archive -o ..&#x2F;latest.zip NEW_COMMIT_ID_HERE $(git diff --name-only </span><br><span class="line">OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE)</span><br></pre></td></tr></table></figure>
<h3 id="克隆一个特定的远程分支"><a href="#克隆一个特定的远程分支" class="headerlink" title="克隆一个特定的远程分支"></a>克隆一个特定的远程分支</h3><p>如果你想从远程仓库克隆特定的一个分支，这条命令对你很有用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line"></span><br><span class="line">git remote add -t BRANCH_NAME_HERE -f origin REMOTE_REPO_URL_PATH_HERE </span><br><span class="line"></span><br><span class="line">git checkout BRANCH_NAME_HERE</span><br></pre></td></tr></table></figure>

<h3 id="从无关的本地仓库应用补丁"><a href="#从无关的本地仓库应用补丁" class="headerlink" title="从无关的本地仓库应用补丁"></a>从无关的本地仓库应用补丁</h3><p>如果您需要申请从提交的一些其他不相关的创库到本地存储库，这里是一个快捷的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --git-dir&#x3D;PATH_TO_OTHER_REPOSITORY_HERE&#x2F;.git format-patch -k -1 --stdout</span><br><span class="line"></span><br><span class="line">COMMIT_HASH_ID_HERE| git am -3 -k</span><br></pre></td></tr></table></figure>

<h3 id="检查您的分支变化是是否其他分支的一部分"><a href="#检查您的分支变化是是否其他分支的一部分" class="headerlink" title="检查您的分支变化是是否其他分支的一部分"></a>检查您的分支变化是是否其他分支的一部分</h3><p>cherry 命令可以让你检查你的分支的变化是否存在于其他一些分支之中。它会显示在当前分支相对于给定的分支的修改，用+或-标志提示提交合并与否。+表示不存在，而-表示存在于给定的分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry -v OTHER_BRANCH_NAME_HERE </span><br><span class="line"></span><br><span class="line">#For example: to check with master branch </span><br><span class="line">git cherry -v master</span><br></pre></td></tr></table></figure>

<h3 id="启动一个无历史的新分支"><a href="#启动一个无历史的新分支" class="headerlink" title="启动一个无历史的新分支"></a>启动一个无历史的新分支</h3><p>有时候，你需要启动一个新的分支，同时想摒弃历史信息，例如，你想将代码放在公共领域（开源）又不想共享历史信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout --orphan NEW_BRANCH_NAME_HERE</span><br></pre></td></tr></table></figure>

<h3 id="在不切换分支的情况下从其它分支检出文件"><a href="#在不切换分支的情况下从其它分支检出文件" class="headerlink" title="在不切换分支的情况下从其它分支检出文件"></a>在不切换分支的情况下从其它分支检出文件</h3><p>下面的命令是从其他分支获取文件，而不用切换分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout BRANCH_NAME_HERE -- PATH_TO_FILE_IN_BRANCH_HERE</span><br></pre></td></tr></table></figure>

<h3 id="忽略跟踪文件的修改"><a href="#忽略跟踪文件的修改" class="headerlink" title="忽略跟踪文件的修改"></a>忽略跟踪文件的修改</h3><p>如果你工作在一个团队，他们都是工作在同一个分支，你需要频繁的读取/合并文件。但是有时复位了你环境的特定配置，你必须在合并后每一次都再改一下。使用这个命令，你可以忽略更改特定的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git update-index --assume-unchanged PATH_TO_FILE_HERE</span><br></pre></td></tr></table></figure>

<h3 id="检查提交的修改是否发布版本的一部分"><a href="#检查提交的修改是否发布版本的一部分" class="headerlink" title="检查提交的修改是否发布版本的一部分"></a>检查提交的修改是否发布版本的一部分</h3><p>这个 name-rev 命令可以告诉你提交相对于最新发布版本的位置。利用这一点，你可以检查你的变化是否发布版本的一部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git name-rev --name-only COMMIT_HASH_HERE</span><br></pre></td></tr></table></figure>

<h3 id="使用-pull-rebase-操作替代-merge"><a href="#使用-pull-rebase-操作替代-merge" class="headerlink" title="使用 pull rebase 操作替代 merge"></a>使用 pull rebase 操作替代 merge</h3><p>如果你工作的团队正工作在同一个分支，那么你所要做的获取/合并或经常拉取。分支合并的 git 记录与合并提交时提示功能分支被并入主干。但在多个团队成员工作的同一分支的情况下，经常合并导致在日志中多个合并的消息引起混乱。所以你可以使用 pull rebase，以保持历史信息清除了无用合并的消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config branch.BRANCH_NAME_HERE.rebase true</span><br></pre></td></tr></table></figure>
<p>此外，您可以配置一个特定的分支总是衍合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gentoo安装RTL8723BE无线网卡驱动</title>
    <url>/ipfs/an-zhuang-rtl8723bewu-xian-wang-qia-qu-dong/</url>
    <content><![CDATA[<blockquote>
<p>新配了个ThinkPad E55c 安装Gentoo时无线网卡没能正确识别。网上查了一下是3.15内核版本之前还没有包含这个驱动，需要手动安装一下。但是我想说我安装的内核版本是4.1,而且也安装了linux-firmware固件，可是怎么就没有这个驱动呢 - - 暂时先不深究。</p>
</blockquote>
<ul>
<li>内核版本：Kernel: x86_64 Linux 4.1.15-gentoo-r1</li>
<li>网卡型号：RTL8723BE</li>
</ul>
<h3 id="确认网卡型号"><a href="#确认网卡型号" class="headerlink" title="确认网卡型号"></a>确认网卡型号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci -k | grep Network</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-18_04-16-28.png" alt=""></p>
<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;lwfinger&#x2F;rtlwifi_new.git</span><br><span class="line">cd rtlwifi_new&#x2F;</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="手动加载模块"><a href="#手动加载模块" class="headerlink" title="手动加载模块"></a>手动加载模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modprobe rtl8723be        ## 手动加载rtl8723be模块</span><br><span class="line">modinfo rtl8723be         ## 查看模块详情</span><br></pre></td></tr></table></figure>

<p>模块加载成功，使用<code>lspci -k</code>看一下,如果显示的是如下图说明无线网卡驱动安装成功：<br><img data-src="/content/images/2016/03/--_2016-03-18_04-17-37.png" alt=""><br>最后<code>ip addr show</code>可以看到对应的网卡设备了<br><img data-src="/content/images/2016/03/--_2016-03-18_04-30-58.png" alt=""></p>
<h3 id="自启动加载模块"><a href="#自启动加载模块" class="headerlink" title="自启动加载模块"></a>自启动加载模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;conf.d&#x2F;modules</span><br><span class="line">modules&#x3D;&quot;rtl8723be&quot;</span><br></pre></td></tr></table></figure>
<p><a href="https://wiki.archlinux.org/index.php/Wireless_network_configuration" target="_blank" rel="noopener">引用</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>Gentoo</tag>
        <tag>rtl8723be</tag>
      </tags>
  </entry>
  <entry>
    <title>Arch Linux 降级安装软件包与禁止自动升级指定软件包</title>
    <url>/ipfs/arch-linuxjiang-ji-an-zhuang-ruan-jian-bao-yu-jin-zhi-sheng-ji-bu-xiang-sheng-ji-de-bao-de-fang-fa/</url>
    <content><![CDATA[<blockquote>
<p>由于 Arch Linux 采用滚动更新，最近php7.0也开始更新升级了，但是这会导致目前项目还是采用的mysql模块的程序来说真真是不适合升级的。所以，这里在网上查了一下降级安装的方法分享这里。</p>
</blockquote>
<h3 id="通过备份软件包降级安装"><a href="#通过备份软件包降级安装" class="headerlink" title="通过备份软件包降级安装"></a>通过备份软件包降级安装</h3><p>找到相应的php备份包，如果你最近没有执行 pacman -Scc以清空包缓存的话，应该在那儿)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg | grep php</span><br></pre></td></tr></table></figure>
<p>如果在，你可以执行pacman -U ×××.pkg.tar.gz来安装旧版本。如果pacman提示文件冲突的话，你可以通过加上-f参数以强制执行，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -U --force ×××.pkg.tar.gz</span><br></pre></td></tr></table></figure>
<p>这个过程会移除现有的包，仔细的计算所有依赖的改变，然后安装你选择的旧版本的软件包以及合适的依赖。</p>
<h3 id="通过downgrade程序来自动化降级安装软件包"><a href="#通过downgrade程序来自动化降级安装软件包" class="headerlink" title="通过downgrade程序来自动化降级安装软件包"></a>通过downgrade程序来自动化降级安装软件包</h3><p><em>在 AUR 中有一个包叫做downgradeAUR。它是一个简单的 Bash 脚本，它会从你的缓存中寻找旧版本的包，如果没有的话它会搜索 A.R.M.。你可以选择一个旧包来安装。它基本上自动化了上面所述的过程。查看 downgrade –help 获取使用方法的信息。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yaourt -S downgrade</span><br><span class="line">downgrade -s php              ##搜索相关包版本</span><br><span class="line">downgrade php                 ##降级安装包</span><br></pre></td></tr></table></figure>
<h3 id="如何恢复所有包到指定日期"><a href="#如何恢复所有包到指定日期" class="headerlink" title="如何恢复所有包到指定日期"></a>如何恢复所有包到指定日期</h3><p>如果想恢复所有包到指定日期（比如2014年3月30日），你必须如下例所示编辑 /etc/pacman.conf，从而让 pacman 保持在这个时间点并且直接使用指定的服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">SigLevel &#x3D; PackageRequired</span><br><span class="line">Server&#x3D;http:&#x2F;&#x2F;ala.seblu.net&#x2F;repos&#x2F;2014&#x2F;03&#x2F;30&#x2F;$repo&#x2F;os&#x2F;$arch</span><br><span class="line"></span><br><span class="line">[extra]</span><br><span class="line">SigLevel &#x3D; PackageRequired</span><br><span class="line">Server&#x3D;http:&#x2F;&#x2F;ala.seblu.net&#x2F;repos&#x2F;2014&#x2F;03&#x2F;30&#x2F;$repo&#x2F;os&#x2F;$arch</span><br><span class="line"></span><br><span class="line">[community]</span><br><span class="line">SigLevel &#x3D; PackageRequired</span><br><span class="line">Server&#x3D;http:&#x2F;&#x2F;ala.seblu.net&#x2F;repos&#x2F;2014&#x2F;03&#x2F;30&#x2F;$repo&#x2F;os&#x2F;$arch</span><br></pre></td></tr></table></figure>
<p>或者如下例编辑 /etc/pacman.d/mirrorlist：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##                                                                              </span><br><span class="line">## Arch Linux repository mirrorlist                                             </span><br><span class="line">## Generated on 2042-01-01                                                      </span><br><span class="line">##</span><br><span class="line">Server&#x3D;http:&#x2F;&#x2F;ala.seblu.net&#x2F;repos&#x2F;2014&#x2F;03&#x2F;30&#x2F;$repo&#x2F;os&#x2F;$arch</span><br></pre></td></tr></table></figure>
<p>然后同步包数据库以强制降级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pacman -Syyuu</span><br></pre></td></tr></table></figure>

<h3 id="禁止指定包自动升级的方法"><a href="#禁止指定包自动升级的方法" class="headerlink" title="禁止指定包自动升级的方法"></a>禁止指定包自动升级的方法</h3><p>==注意: 如果你改变了操作系统的一个基本的组件包，你也许需要降级许多包。这些软件包可能在过程中被删除，需要手动一点一点的安装回来；同时，后续升级时要小心，不要重新安装不想要的软件包版本。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;rc.conf</span><br></pre></td></tr></table></figure>

<p>添加行</p>
<p>IgnorePkg = php php-cgi php-gd</p>
<p>这样子,我们就可以禁止上面的三个包自动升级了.如果有其它的包想禁止,直接添加就可以了,记住分隔符要用空格哦.</p>
<p><a href="https://wiki.archlinux.org/index.php/Downgrading_packages_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">参考文档1</a><br><a href="https://wiki.archlinux.org/index.php/Arch_Linux_Archive_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">参考文档2</a><br><a href="http://www.nenew.net/arch-linux-downgrade-install-packages-prevent-packages-update.html" target="_blank" rel="noopener">引用</a></p>
]]></content>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
        <tag>pacman</tag>
      </tags>
  </entry>
  <entry>
    <title>Ghost博客手工修改管理员密码方法</title>
    <url>/ipfs/ghostbo-ke-shougong-xiu-gai-mi-ma/</url>
    <content><![CDATA[<blockquote>
<p>今天修改Ghost密码，因为是粘贴复制，估计是粘贴到了其他字符，导致密码错误登陆后台失败。而且还因为登录尝试次数过多，造成用户被锁定，只能通过发送邮件找回密码，但是，我配置的Gmail邮箱被google限制使用收发邮件功能了应该，以后看一下具体的原因。</p>
</blockquote>
<h3 id="查找sqlite数据库用户信息"><a href="#查找sqlite数据库用户信息" class="headerlink" title="查找sqlite数据库用户信息"></a>查找sqlite数据库用户信息</h3><p>Ghost用的sqlite数据库，登陆到服务器，找到sqlite数据库，存放位置默认是在 Ghost 安装目录下的 content/data/ ，名称为ghost.db使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;data&#x2F;www&#x2F;ghost&#x2F;content&#x2F;data&#x2F;</span><br><span class="line">$ sudo sqlite3 ghost.db</span><br><span class="line">sqlite&gt; .help     ### 这里已经进到sqlite命令行模式下了，用&quot;.help&quot;查看帮助</span><br><span class="line">sqlite&gt; .tables   ### 列表所有的表</span><br><span class="line">sqlite&gt; .schema   ### 列表所有表的结构 这里我们主要看users表  </span><br><span class="line">sqlite&gt; selete * from users;</span><br></pre></td></tr></table></figure>
<p>到这里就可以列出后台登陆的会员信息了，仔细看一下发现有个status字段的值应该是locked; password字段值是一串使用 <a href="http://bcrypthashgenerator.apphb.com/" target="_blank" rel="noopener">BCrypt Hash Generator</a> 生成的密钥。</p>
<h3 id="修改密码为新生成的密钥"><a href="#修改密码为新生成的密钥" class="headerlink" title="修改密码为新生成的密钥"></a>修改密码为新生成的密钥</h3><p>// 更新密码 这里的密码为 admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; update users set password &#x3D; &quot;$2a$10$ahse9xU.Tr9MttVX4tO1zOER7odgDrQuJzgjZI4fm56x84c&#x2F;2dGqq&quot; where id &#x3D; 1;         ### 更新密码</span><br><span class="line">sqlite&gt; update users set status &#x3D; &quot;active&quot; where id &#x3D; 1;       ### 解锁用户</span><br><span class="line">sqlite&gt; .quit</span><br></pre></td></tr></table></figure>
<p>完成以上两步，就可以重新登录了。</p>
]]></content>
      <tags>
        <tag>ghost</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 学习笔记1</title>
    <url>/ipfs/java-xue-xi-bi-ji/</url>
    <content><![CDATA[<blockquote>
<p>以下是在Arch Linux下操作，其他发行版或操作系统不适用。Maven这个词可以翻译为“知识的积累”，也可以翻译为“专 家”或“内行”。本文将介绍Maven这一跨平台的项目管理工具。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。</p>
</blockquote>
<h2 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S jdk8-openjdk</span><br></pre></td></tr></table></figure>
<p>安装好以后可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">archlinux-java help             ##查看帮助</span><br><span class="line">archlinux-java status           ##java环境状态 使用的版本信息</span><br></pre></td></tr></table></figure>

<h2 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>maven 会被安装到<code>/opt/maven/</code> 目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S maven</span><br></pre></td></tr></table></figure>
<p>修改环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-20_17-18-19.png" alt=""></p>
<p>这样以后，就可以使用 mvn 命令来管理java项目，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;gyapp&#x2F;                ###进入工作目录。(自定义)     </span><br><span class="line">mvn archetype:generate -DgroupId&#x3D;helloworld -DartifactId&#x3D;helloworld </span><br><span class="line">-Dpackage&#x3D;helloworld -Dversion&#x3D;1.0-SNAPSHO</span><br></pre></td></tr></table></figure>

<h3 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h3><p>执行了上面的命令会在当前工作目录生成helloworld项目目录。<br><img data-src="/content/images/2016/01/--_2016-01-20_17-24-58.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd helloworld&#x2F;</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<p>这个时候， maven 在 helloworld 下面建立了一个新的目录 target/ ，构建打包后的 jar 文件 helloworld-1.0-SNAPSHOT.jar 就存放在这个目录下。编译后的 class 文件放在 target/classes/ 目录下面，测试 class 文件放在 target/test-classes/ 目录下面。</p>
<p><img data-src="/content/images/2016/01/--_2016-01-20_17-26-01.png" alt=""></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>为了验证我们的程序能运行，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp target&#x2F;helloworld-1.0-SNAPSHOT.jar helloworld.App</span><br></pre></td></tr></table></figure>
<p>输出源代码里的程序，显示 HelloWorld! 表示成功。</p>
<h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi HelloWorld.java</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-20_17-10-49.png" alt=""><br>编译源代码，在当前目录生成HelloWorld.class,然后执行<code>java HelloWorld</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>

<h2 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h2><p>转换ppk成linux下面支持的密钥文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S putty</span><br></pre></td></tr></table></figure>
<p>安装putty以后，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">puttygen git_cesi.ppk -o id_rsa.pub -O public-openssh</span><br><span class="line">puttygen git_cesi.ppk -o id_rsa -O private-openssh</span><br></pre></td></tr></table></figure>

<p><a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Ghost 加载慢问题分析</title>
    <url>/ipfs/ghost-jia-zai-man-wen-ti-fen-xi/</url>
    <content><![CDATA[<p>Ghost 搭建完能正常访问，可是墙内访问实在太慢了，按F12打开Chrome 开发者工具可以看到主要是 <a href="http://fonts.googleapis.com" target="_blank" rel="noopener">http://fonts.googleapis.com</a> 这个访问使用了太长的时间。应该是GFW搞的鬼，使得 Google Fonts 服务也受影响了，Ghost 后台和默认主题都引用了 Google Fonts 服务，已至于每次打开自己的 Ghost 博客都很慢。</p>
<p><em>这样我们就知道了问题的关键，马上登陆服务器，进入ghost目录。</em></p>
<pre><code>$ cd /data/www/ghost
$ grep &apos;fonts.googleapis.com&apos; -n --color  -r  .</code></pre><p><img data-src="/content/images/2015/05/--_2015-05-11_14-04-18.png" alt=""><br><em>使用sed删除相应的行</em></p>
<pre><code>$ sudo sed -i &apos;19d&apos; ./content/themes/casper/default.hbs</code></pre><p>上面修改的地方其实就是删除 Ghost 系统内引用的 Google Fonts 英文字体文件，这对于国内的用户丝毫没有影响，毕竟我们用的是 中文 嘛。</p>
<p>经过修改，Google Fonts 文件就被彻底清除了。然后重启 Ghost 系统，再登录你的博客看看吧！</p>
<pre><code>$ sudo -i 
$ pm2 restart ghost</code></pre>]]></content>
      <tags>
        <tag>ghost</tag>
        <tag>google fonts</tag>
        <tag>sed</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 学习笔记2</title>
    <url>/ipfs/java-xue-xi-bi-ji-2-2/</url>
    <content><![CDATA[<h2 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h2><p>由于maven的中央仓库位于国外，速度慢，也有可能其他原因无法访问，我们可以使用国内的镜像仓库。配置镜像仓库需要修改conf/settings.xml,打开该文件修改mirror标签如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;opt&#x2F;maven&#x2F;conf&#x2F;settings.xml</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-20_19-42-35.png" alt=""></p>
<p>maven仓库默认是放在用户目录的.m2隐藏目录下的 ~/.m2/repository/ 。如果需要将仓库迁移到其他目录，修改conf/settings.xml<br><img data-src="/content/images/2016/01/--_2016-01-20_19-52-27.png" alt=""></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>配置maven编译程序过程中可用的最大，最下内存，防止内存溢出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAVEN_OPTS&#x3D;&quot;-Xms256m -Xmx512m&quot;</span><br><span class="line">export MAVEN_OPTS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置web服务一定要记得设置compressableMimeType<br><img data-src="/content/images/2016/01/--_2016-01-25_16-02-11.png" alt=""></p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX ssh 用户配置文件 config 管理</title>
    <url>/ipfs/linux-ssh-yong-hu-pei-zhi-wen-jian-config-guan-li/</url>
    <content><![CDATA[<blockquote>
<p>利用 ssh 的用户配置文件 config 管理 ssh 会话。ssh 的用户配置文件是放在当前用户根目录下的 .ssh 文件夹里（~/.ssh/config，不存在则新创建一个），其配置写法如下：</p>
</blockquote>
<pre><code>Host test
    User root
    HostName 192.168.3.152
    PassWord V8kbwqsV0UGTob8EEeL4
Host *
    #PubkeyAuthentication no
    IdentityFile    ~/.ssh/id_rsa</code></pre><p>这样我们就可以使用如下命令直接登陆到hostname 为192.168.3.152 的服务器了：</p>
<pre><code># ssh test</code></pre><p>使用密钥的好处就是省去每次 ssh 登陆服务器时都要输入登陆密码的操作，这里使用 ssh-keygen 生成 ssh 密钥与公钥：</p>
<pre><code># ssh-keygen -t rsa</code></pre><p>把公钥 id_rsa.pub 上传到远程 192.168.3.152 服务器的 ~/.ssh/ 目录下：</p>
<pre><code># ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.3.152</code></pre><p>这样会在服务器的 ~/.ssh/ 目录下生成文件 authorized_keys</p>
<p><strong>这里注意一点：以 ssh publickey 的形式访问，对当前用户根目录下的 .ssh 文件夹里的目录文件是要有一定的权限要求，之前遇到过 ssh publickey 配置好了，不过用 publickey 登陆验证时则无效。所以，最好设下.ssh 目录权限为 700，authorized_keys 权限为 600，并检查当前用户目录所属的用户组，如：</strong></p>
<pre><code># ls -al .ssh/
total 12
drwx------  2 root root 4096 Jun 13 16:20 .
drwxr-xr-x. 5 other others 4096 Jun 13 16:15 ..
-rw-------  1 root root  401 Jun 13 16:20 authorized_keys</code></pre><p>以上，注意目录 .ssh/ 父目录用户所属用户组，用户。这样也会造成使用publickey 登陆验证时无效，还是提示要输入密码。</p>
<pre><code># chown -R root.root /root/</code></pre><p>当然，用密钥的方式连接服务器是需要服务器上的 ssh 支持的，需要 ssh 的配置文件（默认是在 etc/ssh/sshd_config）里的 PubkeyAuthentication 设置成 yes。如果要改登陆的端口，直接把 Port 改成你想要的端口值就行。修改完后重启下 ssh ，配置就生效：</p>
<pre><code># /etc/init.d/sshd restart</code></pre><p>然后，就可以使用ssh 别名登陆服务器了。</p>
<p>用 ssh 作 socks5 代理翻墙，以后不用这样写了(hcj.com 为在墙外的代理服务器)：</p>
<pre><code># ssh -CfNg -D1080 hcj.com</code></pre><p>使用 scp 传送可以简写成这样：</p>
<pre><code># scp ~/.ssh/id_rsa.pub test:~/.ssh/authorized_keys</code></pre><p>执行远程 ssh 命令：</p>
<pre><code># ssh test &apos;ls -al ~&apos;</code></pre><p>打包一个文件（假设当前目录有个名为 test 的文件夹），接着上传到远程服务器，最后解压文件</p>
<pre><code># tar -zcvf - ./test/ | ssh test &apos;cd /user/; tar xvfz -&apos;</code></pre>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下终端里好玩与危险命令汇总</title>
    <url>/ipfs/linux-xia-hao-wan-de-ming-ling/</url>
    <content><![CDATA[<blockquote>
<p>最近发现Linux 终端里有很多好玩的命令，这里记录一下，以免下次还得搜索 - -</p>
</blockquote>
<h2 id="一些好玩的命令"><a href="#一些好玩的命令" class="headerlink" title="一些好玩的命令"></a>一些好玩的命令</h2><h3 id="sl"><a href="#sl" class="headerlink" title="sl"></a>sl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sl</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/2012111315222236.jpg" alt=""></p>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ telnet towel.blinkenlights.nl</span><br></pre></td></tr></table></figure>
<h3 id="rev"><a href="#rev" class="headerlink" title="rev"></a>rev</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rev</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-39-09.png" alt=""></p>
<h3 id="factor"><a href="#factor" class="headerlink" title="factor"></a>factor</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ factor</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-32-16.png" alt=""></p>
<h3 id="cowsay"><a href="#cowsay" class="headerlink" title="cowsay"></a>cowsay</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cowsay &#x2F; cowthink</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-41-06.png" alt=""></p>
<h3 id="fortune"><a href="#fortune" class="headerlink" title="fortune"></a>fortune</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fortune &#x2F; fortune-zh</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-42-01.png" alt=""></p>
<h3 id="cmatrix"><a href="#cmatrix" class="headerlink" title="cmatrix"></a>cmatrix</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cmatrix</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-42-45.png" alt=""></p>
<h3 id="yes"><a href="#yes" class="headerlink" title="yes"></a>yes</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yes</span><br><span class="line">$ yes I love China</span><br></pre></td></tr></table></figure>
<p>yes 是一个非常有趣又有用的命令，尤其对于脚本编写和系统管理员来说，它可以自动地生成预先定义的响应或者将其传到终端。</p>
<h3 id="toilet"><a href="#toilet" class="headerlink" title="toilet"></a>toilet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ toilet hcaijin.com</span><br><span class="line">$ toilet -f mono12 -F metal hcaijin.com</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-47-46.png" alt=""></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ while true; do echo &quot;$(date &#39;+%D %T&#39; | toilet -f term -F border --gay)&quot;; sleep 1; done</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-49-59.png" alt=""></p>
<h3 id="espeak"><a href="#espeak" class="headerlink" title="espeak"></a>espeak</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ espeak &quot;Tecmint is a very good website dedicated to Foss Community&quot;</span><br></pre></td></tr></table></figure>
<p>将你的多媒体音箱的音量调到最大，然后在将这个命令复制到你的终端，来看看你听到上帝的声音时的反应吧。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..19&#125;; do for j in $(seq 1 $i); do echo -ne $i x $j&#x3D;$((i*j))\\t;done; echo;done</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-44-41.png" alt=""></p>
<h3 id="banner"><a href="#banner" class="headerlink" title="banner"></a>banner</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ banner hcaijin.com</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_10-58-38.png" alt=""></p>
<h2 id="终端下有很多危险的命令，千万小心执行。"><a href="#终端下有很多危险的命令，千万小心执行。" class="headerlink" title="终端下有很多危险的命令，千万小心执行。"></a>终端下有很多危险的命令，千万小心执行。</h2><h3 id="fork炸弹"><a href="#fork炸弹" class="headerlink" title="fork炸弹"></a>fork炸弹</h3><p>这个命令其实是一个fork炸弹，它会以指数级的自乘，直到所有的系统资源都被利用了或者系统挂起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ :()&#123; :|:&amp; &#125;:</span><br></pre></td></tr></table></figure>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除命令，一定要小心不可用root用户执行以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -rf &#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>很有用的命令，但是要注意不要运行以下命令，其实我也没有运行过- -</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;mem</span><br></pre></td></tr></table></figure>

<h3 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h3><p>覆盖文件让它不能再读，传说中的文件粉碎机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ shred --help</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-13_11-03-46.png" alt=""></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux dd</title>
    <url>/ipfs/linux-dd/</url>
    <content><![CDATA[<blockquote>
<p>dd 是 Linux/UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
</blockquote>
<p>常用：<br>dd 命令生成文件test.data 大小为1024M<br><code>$ dd if=/dev/zero of=test.data bs=1024M count=1</code></p>
<h3 id="整盘数据备份与恢复"><a href="#整盘数据备份与恢复" class="headerlink" title="整盘数据备份与恢复"></a>整盘数据备份与恢复</h3><p>将本地的/dev/sda1整盘备份到/dev/sda2<br><code>$ dd if=/dev/sda1 of=/dev/sda2</code><br>将/dev/sda2全盘数据备份到指定路径的image文件<br><code>$ dd if=/dev/sda2 of=/path/to/image</code><br>备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径<br><code>$ dd if=/dev/hdx | gzip &gt;/path/to/image.gz</code><br>将备份文件恢复到指定盘：<br><code>$ dd if=/path/to/image of=/dev/hdx</code><br>将压缩的备份文件恢复到指定盘:<br><code>$ gzip -dc /path/to/image.gz | dd of=/dev/hdx</code>   </p>
<h3 id="利用netcat远程备份"><a href="#利用netcat远程备份" class="headerlink" title="利用netcat远程备份"></a>利用netcat远程备份</h3><p>在源主机上执行此命令备份/dev/hda<br><code>$ dd if=/dev/hda bs=16065b | netcat &lt; targethost-IP &gt; 1234</code><br>在目的主机上执行此命令来接收数据并写入/dev/hdc<br><code>$ netcat -l -p 1234 | dd of=/dev/hdc bs=16065b</code><br>以下两条指令是目的主机指令的变化分别采用bzip2  gzip对数据进行压缩，并将备份文件保存在当前目录。  </p>
<pre><code>$ netcat -l -p 1234 | bzip2 &gt; partition.img
$ netcat -l -p 1234 | gzip &gt; partition.img</code></pre><h3 id="备份MBR"><a href="#备份MBR" class="headerlink" title="备份MBR"></a>备份MBR</h3><p>备份磁盘开始的512Byte大小的MBR信息到指定文件<br><code>$ dd if=/dev/hdx of=/path/to/image count=1 bs=512</code><br>将备份的MBR信息写到磁盘开始部分<br><code>$ dd if=/path/to/image of=/dev/hdx</code>   </p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p><em>#### 得到最恰当的block size</em></p>
<pre><code>dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file 
           dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file
           dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file
           dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</code></pre><p>通过比较dd指令输出中所显示的命令执行时间，即可确定系统最佳的block size大小</p>
<p><em>#### 测试硬盘读写速度</em>   </p>
<pre><code>$ dd if=/root/1Gb.file bs=64k | dd of=/dev/null
           $ dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000</code></pre><p>通过上两个命令输出的执行时间，可以计算出测试硬盘的读／写速度        </p>
<p><em>#### 修复硬盘</em><br><code>$ dd if=/dev/sda of=/dev/sda</code><br>当硬盘较长时间（比如1，2年）放置不使用后，磁盘上会产生magnetic flux point。当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生。且这个过程是安全，高效的。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><em>#### 将软驱数据备份到当前目录的disk.img文件</em><br><code>dd if=/dev/fd0 of=disk.img count=1 bs=1440k</code>    </p>
<p><em>#### 拷贝内存资料到硬盘</em><br><code>$ dd if=/dev/mem of=/root/mem.bin bs=1024</code><br>将内存里的数据拷贝到root目录下的mem.bin文件</p>
<p><em>#### 从光盘拷贝iso镜像</em><br><code>$ dd if=/dev/cdrom of=/root/cd.iso</code><br>拷贝光盘数据到root文件夹下，并保存为cd.iso文件                </p>
<p><em>#### 增加Swap分区文件大小</em><br><code>$ dd if=/dev/zero of=/swapfile bs=1024 count=262144</code><br>创建一个足够大的文件（此处为256M）<br><code>$ mkswap /swapfile</code><br>把这个文件变成swap文件<br><code>$ swapon /swapfile</code><br>启用这个swap文件<br><code>$ /swapfile swap swap defaults 0 0</code><br>在每次开机的时候自动加载swap文件, 需要在 /etc/fstab 文件中增加一行</p>
<p><em>#### 销毁磁盘数据</em><br><code>$ dd if=/dev/urandom of=/dev/hda1</code><br>利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。执行此操作以后，/dev/hda1将无法挂载，创建和拷贝操作无法执行。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>dd</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux gentoo U盘安装指南</title>
    <url>/ipfs/gentoo-upan-an-zhuang-zhi-nan/</url>
    <content><![CDATA[<blockquote>
<p>再一次捣鼓gentoo,还是遇到了相当多的麻烦，这里把安装的方法重新在blog里整理一下，跟着官方安装步骤一点点来。</p>
</blockquote>
<h2 id="准备安装之前"><a href="#准备安装之前" class="headerlink" title="准备安装之前"></a>准备安装之前</h2><h3 id="下载gentoo所需的引导镜像和系统文件压缩包"><a href="#下载gentoo所需的引导镜像和系统文件压缩包" class="headerlink" title="下载gentoo所需的引导镜像和系统文件压缩包"></a>下载gentoo所需的引导镜像和系统文件压缩包</h3><p>下载地址：<br><a href="https://www.gentoo.org/downloads/" target="_blank" rel="noopener">https://www.gentoo.org/downloads/</a></p>
<p>主要文件：</p>
<ul>
<li>install-amd64-minimal-20160303.iso            </li>
<li>portage-latest.tar.bz2</li>
<li>stage3-amd64-20160303.tar.bz2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir gentoo&#x2F;  &amp;&amp; cd gentoo&#x2F;</span><br><span class="line">$ wget -c  # http:&#x2F;&#x2F;mirrors.163.com&#x2F;gentoo&#x2F;releases&#x2F;amd64&#x2F;autobuilds&#x2F;20160303&#x2F;install-amd64-minimal-20160303.iso</span><br><span class="line">$ wget -c http:&#x2F;&#x2F;mirrors.163.com&#x2F;gentoo&#x2F;snapshots&#x2F;portage-latest.tar.bz2</span><br><span class="line">$ wget -c http:&#x2F;&#x2F;mirrors.163.com&#x2F;gentoo&#x2F;releases&#x2F;amd64&#x2F;autobuilds&#x2F;20160303&#x2F;stage3-amd64-20160303.tar.bz2</span><br></pre></td></tr></table></figure>
<h3 id="U盘准备"><a href="#U盘准备" class="headerlink" title="U盘准备"></a>U盘准备</h3><p>插入U盘，查看U盘设备名,不需求挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">$ sudo dd if&#x3D;install-amd64-minimal-20160303.iso of&#x3D;&#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure>
<p>这样，就制作好了U盘启动了，把U盘插入要安装的机子，配置BIOS通过U盘启动，就可以进入光盘引导的临时系统。</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="配置临时系统"><a href="#配置临时系统" class="headerlink" title="配置临时系统"></a>配置临时系统</h3><blockquote>
<p>安装gentoo最主要是先把网络配置好，这里我安装的时候遇到了个非常郁闷的问题，就是，公司的个别网段限制下载，导致我在配置网络的时候浪费了不少时间，所以最好先确认一下，你所在的网段是否可以使用wget下载文件。</p>
</blockquote>
<h4 id="配置IP"><a href="#配置IP" class="headerlink" title="配置IP"></a>配置IP</h4><p>通常启动U盘临时系统应该可以dhcp分配到一个ip,但是我因为是公司的网络，所以最好手动配置一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ip addr add 192.168.3.155&#x2F;24 dev enp0s25</span><br><span class="line"># ip route add default via 192.168.3.1 dev enp0s25</span><br><span class="line"># echo &quot;192.168.1.1&quot; &gt; &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>

<h4 id="配置ssh链接"><a href="#配置ssh链接" class="headerlink" title="配置ssh链接"></a>配置ssh链接</h4><p>为了方便，最好远程链接到临时系统下，那么就得配置sshd服务。</p>
<p>==Tip: 最新的sshd服务器默认限制root登陆，需要修改一下/etc/ssh/sshd_config<br>配置PermitRootLogin 为 yes==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;sshd start</span><br><span class="line"># passwd root               ####配置root用户密码</span><br></pre></td></tr></table></figure>
<p>以上，我们就可以到本机，使用ssh远程登陆这个U盘挂启的临时系统了</p>
<h3 id="安装到硬盘上"><a href="#安装到硬盘上" class="headerlink" title="安装到硬盘上"></a>安装到硬盘上</h3><h4 id="系统分区fdisk"><a href="#系统分区fdisk" class="headerlink" title="系统分区fdisk"></a>系统分区fdisk</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line">Device     Boot     Start       End   Sectors  Size Id Type</span><br><span class="line">&#x2F;dev&#x2F;sda1            2048      6143      4096    2M ef EFI (FAT-12&#x2F;16&#x2F;32)</span><br><span class="line">&#x2F;dev&#x2F;sda2            6144    268287    262144  128M 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sda3          268288  17045503  16777216    8G 82 Linux swap &#x2F; Solaris</span><br><span class="line">&#x2F;dev&#x2F;sda4        17045504 937703087 920657584  439G  5 Extended</span><br><span class="line">&#x2F;dev&#x2F;sda5        17047552 226762751 209715200  100G 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sda6       226764800 937703087 710938288  339G 83 Linux</span><br><span class="line"># fdisk &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure>
<p>使用fdisk分区以前有详细的说明过，在这里就不再说了。不懂的，请写看一下这个<br><a href="https://www.hcaijin.com/shu-mei-pai-an-zhuang-gentoo-linux/" target="_blank" rel="noopener">树莓派安装Gentoo Linux</a> 1.1.3 节</p>
<p>也可以参照 <a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks" target="_blank" rel="noopener">官方分区方案</a></p>
<h4 id="重新读取sda分区表"><a href="#重新读取sda分区表" class="headerlink" title="重新读取sda分区表:"></a>重新读取sda分区表:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># partx -a &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure>
<h4 id="格式化分区为文件系统"><a href="#格式化分区为文件系统" class="headerlink" title="格式化分区为文件系统"></a>格式化分区为文件系统</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkfs.ext2 &#x2F;dev&#x2F;sda2</span><br><span class="line"># mkfs.ext4 &#x2F;dev&#x2F;sda5</span><br><span class="line"># mkfs.ext4 &#x2F;dev&#x2F;sda6</span><br></pre></td></tr></table></figure>
<h4 id="格式化swap分区并激活"><a href="#格式化swap分区并激活" class="headerlink" title="格式化swap分区并激活"></a>格式化swap分区并激活</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkswap &#x2F;dev&#x2F;sda3</span><br><span class="line"># swapon &#x2F;dev&#x2F;sda3</span><br></pre></td></tr></table></figure>

<h4 id="创建系统临时挂载点"><a href="#创建系统临时挂载点" class="headerlink" title="创建系统临时挂载点"></a>创建系统临时挂载点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount &#x2F;dev&#x2F;sda5 &#x2F;mnt&#x2F;gentoo</span><br><span class="line"># mkdir -p &#x2F;mnt&#x2F;gentoo&#x2F;&#123;boot,home,&#125;</span><br><span class="line"># mount &#x2F;dev&#x2F;sda2 &#x2F;mnt&#x2F;gentoo&#x2F;boot</span><br><span class="line"># mount &#x2F;dev&#x2F;sda6 &#x2F;mnt&#x2F;gentoo&#x2F;home</span><br></pre></td></tr></table></figure>

<h3 id="设定日期和时间"><a href="#设定日期和时间" class="headerlink" title="设定日期和时间"></a>设定日期和时间</h3><p>安装Gentoo之前，请确保日期和时间是否正确设置。错误配置的时钟可能会产生各种奇怪的错误！==主要==！！！</p>
<p>要验证当前日期和时间，运行日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># date</span><br><span class="line">Sat Mar  5 16:26:08 UTC 2016</span><br></pre></td></tr></table></figure>
<p>如果时间不对，请使用 <code>MMDDhhmmYYYY</code> 这样的格式配置一下日期和时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date 030516262016</span><br></pre></td></tr></table></figure>

<h3 id="下载和解压相关包"><a href="#下载和解压相关包" class="headerlink" title="下载和解压相关包"></a>下载和解压相关包</h3><h4 id="使用临时系统自带的links下载stage3和portage"><a href="#使用临时系统自带的links下载stage3和portage" class="headerlink" title="使用临时系统自带的links下载stage3和portage"></a>使用临时系统自带的links下载stage3和portage</h4><p>==Tip:  如果前面已经在本机下载过了可以跳过这一步==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># links https:&#x2F;&#x2F;www.gentoo.org&#x2F;downloads&#x2F;mirrors&#x2F;</span><br></pre></td></tr></table></figure>
<p>或者配置代理下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># links -http-proxy proxy.server.com:8080   https:&#x2F;&#x2F;www.gentoo.org&#x2F;downloads&#x2F;mirrors&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="效验下载的文件"><a href="#效验下载的文件" class="headerlink" title="效验下载的文件"></a>效验下载的文件</h4><p>效验下载的文件是否完整，打开 .DIGESTS(.asc) 相关文件对比sha512加密的是否一至。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># openssl dgst -r -sha512 stage3-amd64-20160303.tar.bz2</span><br></pre></td></tr></table></figure>

<h4 id="解压stage3和portage"><a href="#解压stage3和portage" class="headerlink" title="解压stage3和portage"></a>解压stage3和portage</h4><p>把下载好的stage3和portage放到/mnt/gentoo目录下，进入目录解压：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;mnt&#x2F;gentoo&#x2F;</span><br><span class="line"># tar xvjpf stage3-*.tar.bz2 --xattrs</span><br></pre></td></tr></table></figure>
<p>==注: stage3解压的文件是Gentoo的目录结构，所以要解压到临时的系统目录下,即/mnt/gentoo，方便后面进行chroot==</p>
<p>下面解压portage，这个解压需要一点时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar jxvf portage-latest.tar.bz2 -C &#x2F;mnt&#x2F;gentoo&#x2F;usr</span><br></pre></td></tr></table></figure>
<p>==注: portage-latest.tar.bz2解压的文件为系统软件目录结构,需要解压到/mnt/gentoo/usr目录下==</p>
<h3 id="安装基本gentoo系统"><a href="#安装基本gentoo系统" class="headerlink" title="安装基本gentoo系统"></a>安装基本gentoo系统</h3><h4 id="配置portage-make-参数"><a href="#配置portage-make-参数" class="headerlink" title="配置portage make 参数"></a>配置portage make 参数</h4><ul>
<li>配置了MAKEOPTS为cpu核心数+1</li>
<li>配置就近的镜像地址 GETOO_MIRRORS 为厦门大学的镜像源<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;make.conf</span><br></pre></td></tr></table></figure>
<img data-src="/content/images/2016/03/--_2016-03-05_16-53-28.png" alt=""></li>
</ul>
<p>==Tip: 参数配置文件/mnt/gentoo/usr/share/portage/config/make.conf.example ==</p>
<h4 id="配置主要Gentoo的存储库"><a href="#配置主要Gentoo的存储库" class="headerlink" title="配置主要Gentoo的存储库"></a>配置主要Gentoo的存储库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir &#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;repos.conf</span><br><span class="line"># cp &#x2F;mnt&#x2F;gentoo&#x2F;usr&#x2F;share&#x2F;portage&#x2F;config&#x2F;repos.conf &#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;repos.conf&#x2F;gentoo.conf</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-05_17-00-14.png" alt=""></p>
<h4 id="配置chroot环境的dns"><a href="#配置chroot环境的dns" class="headerlink" title="配置chroot环境的dns"></a>配置chroot环境的dns</h4><p>只需要把livecd临时环境的resolv.conf复制到要chroot的目录里就好了，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -L &#x2F;etc&#x2F;resolv.conf &#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="挂载必要的文件系统"><a href="#挂载必要的文件系统" class="headerlink" title="挂载必要的文件系统"></a>挂载必要的文件系统</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount -t proc proc &#x2F;mnt&#x2F;gentoo&#x2F;proc</span><br><span class="line"># mount --rbind &#x2F;sys &#x2F;mnt&#x2F;gentoo&#x2F;sys</span><br><span class="line"># mount --make-rslave &#x2F;mnt&#x2F;gentoo&#x2F;sys</span><br><span class="line"># mount --rbind &#x2F;dev &#x2F;mnt&#x2F;gentoo&#x2F;dev</span><br><span class="line"># mount --make-rslave &#x2F;mnt&#x2F;gentoo&#x2F;dev</span><br></pre></td></tr></table></figure>

<h4 id="Chroot-到新的环境"><a href="#Chroot-到新的环境" class="headerlink" title="Chroot 到新的环境"></a>Chroot 到新的环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chroot &#x2F;mnt&#x2F;gentoo &#x2F;bin&#x2F;bash</span><br><span class="line"># source &#x2F;etc&#x2F;profile</span><br><span class="line"># export PS1&#x3D;&quot;(chroot) $PS1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>这不是必要的步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sed -i -e &#39;s&#x2F;hostname.*&#x2F;hostname&#x3D;&quot;hcj.com&quot;&#x2F;&#39; &#x2F;etc&#x2F;conf.d&#x2F;hostname</span><br><span class="line"># echo &quot;127.0.0.1 hcj.com localhost&quot; &gt; &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<h4 id="配置Portage"><a href="#配置Portage" class="headerlink" title="配置Portage"></a>配置Portage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># emerge-webrsync</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-05_17-33-41.png" alt=""></p>
<p>我在配置这个的时候报错了，按照提示删除tmestamp.x文件即可。</p>
<p>更新portage树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># emerge --sync</span><br></pre></td></tr></table></figure>
<p>小内存的情况使用静默模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># emerge --sync --quiet</span><br></pre></td></tr></table></figure>

<h4 id="配置系统环境"><a href="#配置系统环境" class="headerlink" title="配置系统环境"></a>配置系统环境</h4><p>查看更新的通知</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># eselect news list</span><br><span class="line"># eselect news read</span><br></pre></td></tr></table></figure>
<p>选择适合的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># eselect profile list</span><br><span class="line"># eselect profile set 3    ### 我选择的是桌面环境系统</span><br></pre></td></tr></table></figure>
<p>更新timezone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls &#x2F;usr&#x2F;share&#x2F;zoneinfo</span><br><span class="line"># echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone</span><br><span class="line"># emerge --config sys-libs&#x2F;timezone-data</span><br></pre></td></tr></table></figure>

<p>配置语言编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># nano -w &#x2F;etc&#x2F;locale.gen</span><br><span class="line"># locale-gen</span><br><span class="line"># eselect locale list</span><br><span class="line">Available targets for the LANG variable:</span><br><span class="line">  [1]   C</span><br><span class="line">  [2]   POSIX</span><br><span class="line">  [3]   en_US</span><br><span class="line">  [4]   en_US.iso88591</span><br><span class="line">  [5]   en_US.utf8</span><br><span class="line">  [6]   zh_CN.utf8 *</span><br><span class="line">  [ ]   (free form)</span><br><span class="line"></span><br><span class="line"># eselect locale set 6</span><br></pre></td></tr></table></figure>
<p>更新一下环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># env-update &amp;&amp; source &#x2F;etc&#x2F;profile &amp;&amp; export PS1&#x3D;&quot;(chroot) $PS1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h3><h4 id="安装内核源码"><a href="#安装内核源码" class="headerlink" title="安装内核源码"></a>安装内核源码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># emerge --ask sys-kernel&#x2F;gentoo-sources</span><br><span class="line"># genkernel --install initramfs</span><br></pre></td></tr></table></figure>
<h4 id="配置fstab"><a href="#配置fstab" class="headerlink" title="配置fstab"></a>配置fstab</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-05_20-12-09.png" alt=""></p>
<h4 id="编译内核文件"><a href="#编译内核文件" class="headerlink" title="编译内核文件"></a>编译内核文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genkernel all</span><br></pre></td></tr></table></figure>
<p>完成以上就可以在/boot目录下看到内核文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls &#x2F;boot&#x2F;kernel* &#x2F;boot&#x2F;initramfs*</span><br></pre></td></tr></table></figure>
<p>==注: genkernel编译出的内核支持几乎所有硬件，编译需要一段很长的时间，一旦genkernel运行完成，一个包括全部模块和initrd的内核将被建立。在后面配置引导程序时我们将会用到这个内核和initrd。请记下内核和initrd的名字，因为您将在配置引导程序的时候用到他们。initrd将会在启动真正的系统前自动识别硬件（如同安装光盘一样）==</p>
<h3 id="安装其他软件"><a href="#安装其他软件" class="headerlink" title="安装其他软件"></a>安装其他软件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># emerge vim                ### 安装vim 方便后面的配置</span><br><span class="line"># emerge syslog-ng          ### 安装系统日志管理</span><br><span class="line"># rc-update add sysklogd default</span><br><span class="line"># emerge logrotate          ### 日志格式化工具</span><br><span class="line"># emerge --ask sys-process&#x2F;cronie    ### 计划任务系统</span><br><span class="line"># rc-update add cronie default</span><br><span class="line"># emerge --ask net-misc&#x2F;dhcpcd   </span><br><span class="line"># emerge --ask sys-apps&#x2F;mlocate       ### 快速索引</span><br></pre></td></tr></table></figure>
<h4 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;conf.d&#x2F;net</span><br><span class="line">config_enp0s25&#x3D;&quot;192.168.3.155 netmask 255.255.255.0 brd 192.168.3.255&quot;</span><br><span class="line">routes_enp0s25&#x3D;&quot;default via 192.168.3.1&quot;</span><br><span class="line"># ln -s &#x2F;etc&#x2F;init.d&#x2F;net.lo &#x2F;etc&#x2F;init.d&#x2F;net.enp0s25</span><br><span class="line"># rc-update add net.enp0s25 default</span><br><span class="line"># rc-update add sshd default</span><br></pre></td></tr></table></figure>
<h4 id="配置root用户密码"><a href="#配置root用户密码" class="headerlink" title="配置root用户密码"></a>配置root用户密码</h4><p>这是必要的，为了从新系统能进入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd</span><br></pre></td></tr></table></figure>

<h3 id="配置GRUB引导程序"><a href="#配置GRUB引导程序" class="headerlink" title="配置GRUB引导程序"></a>配置GRUB引导程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># emerge --ask sys-boot&#x2F;grub:2</span><br><span class="line"># grub2-install &#x2F;dev&#x2F;sda</span><br><span class="line"># grub2-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg</span><br></pre></td></tr></table></figure>

<h3 id="最后重启一下系统"><a href="#最后重启一下系统" class="headerlink" title="最后重启一下系统"></a>最后重启一下系统</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># exit</span><br><span class="line"># cd</span><br><span class="line"># umount -l &#x2F;mnt&#x2F;gentoo&#x2F;dev&#123;&#x2F;shm,&#x2F;pts,&#125;</span><br><span class="line"># umount &#x2F;mnt&#x2F;gentoo&#123;&#x2F;boot,&#x2F;sys,&#x2F;proc,&#125;</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure>

<p><a href="https://gentoo-handbook.lugons.org/doc/zh_cn/handbook/handbook-amd64.xml" target="_blank" rel="noopener">引用</a> </p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>Gentoo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 加解密打包文件</title>
    <url>/ipfs/shi-yong-taryu-openssljia-mi-jie-mi-da-bao-wen-jian/</url>
    <content><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><blockquote>
<p>使用到的命令有tar,openssl,dd</p>
</blockquote>
<p><code>$ mkdir test_dir; cd test_dir/ ; touch test.file; cd .. ; ll test_dir/</code></p>
<p>-rw-r–r– 1 hcaijin hcaijin 0 4月  30 16:35 test.file</p>
<p><code>$ tar -zcvf - test_dir/ | openssl des3 -salt -k password | dd of=test_dir.tag</code></p>
<p>test_dir/<br>test_dir/test.file<br>记录了0+1 的读入<br>记录了0+1 的写出<br>176字节(176 B)已复制，0.0114724 秒，15.3 kB/秒</p>
<p><code>$ dd if=test_dir.tag | openssl des3 -d -k password | tar -zxvf -</code></p>
<p>记录了0+1 的读入<br>记录了0+1 的写出<br>176字节(176 B)已复制，0.000495166 秒，355 kB/秒<br>test_dir/<br>test_dir/test.file</p>
<blockquote>
<p>详细openssl 可查看帮助页</p>
</blockquote>
<p><code>$ man openssl 
 $ openssl enc -h</code><br><img data-src="/content/images/2015/04/--_2015-04-30_17-51-29.png" alt="加密算法列表"></p>
<h2 id="openssl-命令详解"><a href="#openssl-命令详解" class="headerlink" title="openssl 命令详解"></a>openssl 命令详解</h2><p><code>SYNOPSIS 
openssl enc -ciphername [-in filename] [-out filename] [-pass arg] [-e] [-d] [-a] [-A] [-k password] [-kfile filename] [-K key] [-iv IV] [-p] [-P] [-bufsize number] [-nopad] [-debug]
说明：
-chipername选项：加密算法，Openssl支持的算法在上面已经列出了，你只需选择其中一种算法即可实现文件加密功能。
-in选项：输入文件，对于加密来说，输入的应该是明文文件；对于解密来说，输入的应该是加密的文件。该选项后面直接跟文件名。
-out选项：输出文件，对于加密来说，输出的应该是加密后的文件名；对于解密来说，输出的应该是明文文件名。
-pass选项：选择输入口令的方式，输入源可以是标准输入设备，命令行输入，文件、变量等。
-e选项：实现加密功能（不使用-d选项的话默认是加密选项）。
-d选项：实现解密功能。
-a和-A选项：对文件进行BASE64编解码操作。
-K选项：手动输入加密密钥（不使用该选项，Openssl会使用口令自动提取加密密钥）。
-IV选项：输入初始变量（不使用该选项，Openssl会使用口令自动提取初始变量）。
-salt选项：是否使用盐值，默认是使用的。
-p选项：打印出加密算法使用的加密密钥。</code></p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><blockquote>
<p>举例：</p>
</blockquote>
<p><code>$  openssl enc -aes-128-cbc -in pacman.log -out pacman.log.aes</code><br>enter aes-128-cbc encryption password: <strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong><br>Verifying - enter aes-128-cbc encryption password: <strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong><br><em>以上执行成功，生成加密文件 pacman.log.base64，使用以下命令解密：</em><br><code>$ openssl enc -d -aes-128-cbc -in pacman.log.aes -out pacman.out.log</code><br>enter aes-128-cbc decryption password: <strong><strong><strong>****</strong></strong></strong></p>
<blockquote>
<p>下面方法的好处是你可以把它写入到脚本中，自动完成加密功能，不使用pass选项默认系统会提示输入密码并且确认，是需要人工操作的。</p>
</blockquote>
<p><code>$  openssl enc -aes-256-ecb -in pacman.log -out pacman.aes256.log -pass pass:123456 
 $ file pacman.aes256.log</code><br> <em>pacman.aes256.log: data</em><br><code>$ openssl enc -d -aes-256-ecb -out pacman256.log -in pacman.aes256.log</code><br>enter aes-256-ecb decryption password:<br><code>$ file pacman256.log</code><br>pacman256.log: UTF-8 Unicode text</p>
<p><strong><em>生成 pacman256.log 可以用file 看到文件解密为原来的类型了</em></strong>  </p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 声卡驱动问题</title>
    <url>/ipfs/linux-sheng-qia-qu-dong-wen-ti/</url>
    <content><![CDATA[<blockquote>
<p>最近转Gentoo，一切安装就绪了，但是想使用youtube观看视频的时候，竟没有声音，估计又得折腾一下了。</p>
</blockquote>
<p>（Advanced Linux Sound Architecture，ALSA）是Linux中提供声音设备驱动的内核组件，用来代替原来的开放声音系统（Open Sound System，OSSv3）。</p>
<ul>
<li>系统环境：Linux hcj.com 4.1.15-gentoo-r1</li>
<li>组件：alsa</li>
<li>前提：内核已经配置支持</li>
</ul>
<h3 id="硬件设备显示"><a href="#硬件设备显示" class="headerlink" title="硬件设备显示"></a>硬件设备显示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci | grep -i audio</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-21_22-46-22.png" alt=""></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">euse -E alsa</span><br><span class="line">emerge --ask --changed-use --deep @world</span><br><span class="line">emerge --ask alsa-utils</span><br></pre></td></tr></table></figure>

<h3 id="启动声音服务"><a href="#启动声音服务" class="headerlink" title="启动声音服务"></a>启动声音服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;alsasound start</span><br><span class="line">rc-update add alsasound boot      ###声音服务设置boot级别</span><br></pre></td></tr></table></figure>

<h3 id="列出设备名"><a href="#列出设备名" class="headerlink" title="列出设备名"></a>列出设备名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;class&#x2F;sound&#x2F;card*&#x2F;id</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-22_07-16-34.png" alt=""></p>
<h3 id="配置默认设备"><a href="#配置默认设备" class="headerlink" title="配置默认设备"></a>配置默认设备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~&#x2F;.asoundrc</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/03/--_2016-03-22_07-17-59.png" alt=""></p>
<p>最后，别忘了重启一下。</p>
<p><a href="https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://wiki.gentoo.org/wiki/ALSA" target="_blank" rel="noopener">参考链接2</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>alsamixer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 服务器上相关脚本日志</title>
    <url>/ipfs/linux-fu-wu-qi-shang-xiang-guan-jiao-ben-ri-zhi/</url>
    <content><![CDATA[<p>用如下命令查询出来结果中包含“ip地址=数量”的攻击者信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;secure|awk &#39;&#x2F;Failed&#x2F;&#123;print $(NF-3)&#125;&#39;|sort|uniq -c|awk &#39;&#123;print $2&quot;&#x3D;&quot;$1;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>查看IP所在地：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl ipinfo.io&#x2F;&#123;IP&#125;</span><br><span class="line">curl cip.cc&#x2F;&#123;IP&#125;</span><br></pre></td></tr></table></figure>

<p>随机生成密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function randpw32()&#123; &lt; &#x2F;dev&#x2F;urandom tr -dc &#39;!@#$%^&amp;*&#39;_A-Z-a-z-0-9 | head -c$&#123;1:-32&#125;;echo; &#125;</span><br><span class="line"></span><br><span class="line">function randpw16()&#123; &lt; &#x2F;dev&#x2F;urandom tr -dc _A-Z-a-z-0-9 | head -c$&#123;1:-16&#125;;echo; &#125;</span><br></pre></td></tr></table></figure>

<p>Chromium 开启代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function secure_chromium &#123;</span><br><span class="line">    port&#x3D;1080</span><br><span class="line">    #使用以下两种配置都可以</span><br><span class="line">    #export SOCKS_SERVER&#x3D;localhost:$port</span><br><span class="line">    #export SOCKS_VERSION&#x3D;5</span><br><span class="line">    #chromium &amp;</span><br><span class="line">    chromium --proxy-server&#x3D;&quot;socks:&#x2F;&#x2F;localhost:$port&quot; &amp;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统Chrome,Firefox程序无用使用Fcitx的问题解决方法</title>
    <url>/ipfs/linux-xi-tong-chromefirefoxcheng-xu-wu-yong-shi-yong-fcitxde-wen-ti-jie-jue-fang-fa/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>使用的gentoo有半年没有更新系统了，原来用的好好的输入法，更新完以后，在其他的程序都可以正常使用fcitx。但是，在chrome,firefox（后来知道应该是GTK,QT相关的程序用了最新版导致的问题）就是用不了，网上也有很多人提问，也没有一个有效的解决方法。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>Linux hcj-arch 4.4.39-1-lts #1 SMP Thu Dec 15 21:10:18 CET 2016 x86_64 GNU/Linu</li>
<li>fcitx version: 4.2.9.1</li>
<li>Google Chrome 55.0.2883.87</li>
<li>Mozilla Firefox 50.1.0</li>
</ul>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>首先保证环境变量有设置，当然，如果其他程序都可以使用，那这个应该是没有问题的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE&#x3D;fcitx </span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx </span><br><span class="line">export XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br></pre></td></tr></table></figure>
<p>主要的问题就是我们要用命令 <code>fcitx-diagnose</code> 查看fcitx的相关模块是不是有安装。（更无脑的方式就是把这个命令里显示为红色的信息都看一遍，把相关的模块安装上就ok了）</p>
<p>那么，我们可以看到：<br><img data-src="/content/images/2017/01/Screenshot_2016-12-27_10-51-56.png" alt=""></p>
<p><img data-src="/content/images/2017/01/Screenshot_2016-12-27_10-52-09.png" alt=""></p>
<p>== 如上图所示，缺少gtk2,gtk3相关的模块支持，导致的Chrome,Firefox等gtk软件无法使用输入法的情况 ==</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>我们先看一下fcitx构建时用到的USE标记，以下<br><img data-src="/content/images/2017/01/Screenshot_2017-01-09_11-06-32.png" alt=""><br>可以看到，我自己设置的是默认不安装gtk支持的，所以我们要加上，有以下两种方法：</p>
<ul>
<li>可以直接在/etc/portage/make.conf USE标记上加上gtk的支持</li>
<li>直接定义USE标记，加上gtk的支持 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE&#x3D;&quot;X autostart cairo dbus enchant introspection nls pango qt4 table xml -debug gtk2 gtk3 -lua -opencc -static-libs &#123;-test&#125;&quot; sudo emerge fcitx</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>最后，重新编译安装过fcitx以后，再看一下<code>fcitx-diagnose</code>，只要没有红色相关字体的警告信息，就说明已经可以正常使用了。把浏览器重启一下，如果还不行，得重启一下系统。</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>chrome</tag>
        <tag>firefox</tag>
        <tag>fcitx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 终端下发送消息命令</title>
    <url>/ipfs/linux-zhong-duan-xia-fa-song-xiao-xi-ming-ling/</url>
    <content><![CDATA[<blockquote>
<p>这里分享一个Linux服务器终端下发送消息的命令。由于平时工作中，必免不了与运维同事之间的信息交换，想到我们都是链的同一台服务器，这样就可以通过以下两个命令来发送消息。</p>
</blockquote>
<h3 id="给指定用户发送消息"><a href="#给指定用户发送消息" class="headerlink" title="给指定用户发送消息"></a>给指定用户发送消息</h3><p>首先，可使用w或who命令查看当前登录的用户信息；<br>然后，使用write命令将信息发送到用户的终端上，用法步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ w</span><br><span class="line"> 17:17:53 up 19 days, 57 min,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">zq       pts&#x2F;0     14:19    1:50   0.08s  0.02s -bash</span><br><span class="line">hcaijin  pts&#x2F;1     10:30   55.00s  7:05   0.23s -bash</span><br><span class="line">hcaijin  pts&#x2F;2     17:17    1.00s  0.01s  0.00s w</span><br><span class="line"></span><br><span class="line">$ write hcaijin pts&#x2F;1</span><br><span class="line">Test send message.</span><br></pre></td></tr></table></figure>

<p>然后使用hcaijin账号登录，且tty号为pts/1的登录用户终端会收到如下消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Message from hcaijin@hcj-arch on pts&#x2F;2 at 17:18 ...</span><br><span class="line">Test send message.</span><br></pre></td></tr></table></figure>
<h3 id="给当前所有用户发送消息"><a href="#给当前所有用户发送消息" class="headerlink" title="给当前所有用户发送消息"></a>给当前所有用户发送消息</h3><p>给当前登录所有用户发送消息（需要root权限），使用wall（write all的缩写）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wall &#39;Test send message to all user.&#39;</span><br></pre></td></tr></table></figure>
<p>执行wall命令，所有登录到该机器的控制台(console)界面上都会收到如上所示的消息。</p>
<p><a href="http://www.cnblogs.com/gaojun/p/3387427.html" target="_blank" rel="noopener">引用</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>write</tag>
        <tag>wall</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux挂载Mac系统下的dmg文件</title>
    <url>/ipfs/linuxgua-zai-mac-xi-tong-xia-de-dmgwen-jian/</url>
    <content><![CDATA[<blockquote>
<p>最近想在virtualbox下安装Mac系统，了解到Mac的安装镜像文件是dmg格式的，并下载到了 Install OS X Yosemite 10.10.1.dmg 安装包。</p>
</blockquote>
<h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p>本来以为Mac的安装与其他系统的类似，只要把镜像包在虚拟机中做为cd启动就可以了，然而并没什么用 - -</p>
<p>这不，想到把dmg格式的包转化为iso的格式再在虚拟机中启动，这就有了这篇文章的问题了。</p>
<p>google到这个工具acetoneiso可以直接把dmg格式的转为iso</p>
<p>但是，我想是不是可以用更简单的方法来操作。<br>现在的dmg一般都使用(zlib 或者 bzip2压缩算法)压缩过</p>
<p>需要使用dmg2img把dmg文件转为img</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dmg2img Install\ OS\ X\ Yosemite\ 10.10.1.dmg yosemite.img</span><br></pre></td></tr></table></figure>
<p>提示如，就表示成功了：<br>Archive successfully decompressed as yosemite.img</p>
<h2 id="检查模块"><a href="#检查模块" class="headerlink" title="检查模块"></a>检查模块</h2><p>在挂载之前我们要先确保hfsplus模块启用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep hfs</span><br></pre></td></tr></table></figure>
<p>如果没有输出，就表示模块未启用，使用如下命令启用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modprobe hfsplus</span><br></pre></td></tr></table></figure>

<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>启用成功后，就可以用mount挂载img，这里我挂载失败，提示存在坏道，在<a href="http://www.linuxquestions.org/questions/linux-software-2/how-to-mount-dos-img-file-4175430554/" target="_blank" rel="noopener">这里</a>才找到了解决的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t hfsplus -o loop my.img &#x2F;mnt&#x2F;hfs</span><br><span class="line"></span><br><span class="line">mount: wrong fs type, bad option, bad superblock on &#x2F;dev&#x2F;loop0,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line">       In some cases useful info is found in syslog - try</span><br><span class="line">       dmesg | tail or so</span><br></pre></td></tr></table></figure>

<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>查询系统日志在最下面提示如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmesg | tail </span><br><span class="line">[2015609.436682] hfsplus: unable to find HFS+ superblock</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<p>1.先用fdisk查询img扇区<br><img data-src="/content/images/2016/05/--_2016-05-27_17-42-21.png" alt=""><br>可以看到它有两个设备<em>.img1,</em>.img2 </p>
<p>2.把img的文件挂载出来就得找到开始挂载的起始扇区，所以要设置一下offset的值，<br>这里<code>offset=1259643×512</code>，运行以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mount -t hfsplus -v -o loop,offset&#x3D;644937216 yosemite.img &#x2F;mnt&#x2F;hfs</span><br></pre></td></tr></table></figure>

<p>以上，就可以把镜像挂载到了目录/mnt/hfs下。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>mount</tag>
        <tag>mac</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的文件特殊权限</title>
    <url>/ipfs/linuxzhong-de-wen-jian-te-shu-quan-xian/</url>
    <content><![CDATA[<p>linux中除了常见的读（r）、写（w）、执行（x）权限以外，还有3个特殊的权限，分别是setuid、setgid和stick bit</p>
<h2 id="setuid、setgid"><a href="#setuid、setgid" class="headerlink" title="setuid、setgid"></a>setuid、setgid</h2><p>先看个实例，查看你的/usr/bin/passwd 与/etc/passwd文件的权限</p>
<pre><code># ls -l /usr/bin/passwd /etc/passwd
-rw-r--r-- 1 root root  1549 08-19 13:54 /etc/passwd
-rwsr-xr-x 1 root root 22984 2007-01-07 /usr/bin/passwd</code></pre><p>众所周知，/etc/passwd文件存放的各个用户的账号与密码信息，/usr/bin/passwd是执行修改和查看此文件的程序，但从权限上看，/etc/passwd仅有root权限的写（w）权，可实际上每个用户都可以通过/usr/bin/passwd命令去修改这个文件，于是这里就涉及了linux里的特殊权限setuid，正如-rwsr-xr-x中的s</p>
<p>setuid就是：让普通用户拥有可以执行“只有root权限才能执行”的特殊权限，setgid同理指”组“</p>
<p>作为普通用户是没有权限修改/etc/passwd文件的，但给/usr/bin/passwd以setuid权限后，普通用户就可以通过执行passwd命令，临时的拥有root权限，去修改/etc/passwd文件了</p>
<h2 id="stick-bit-（粘贴位）"><a href="#stick-bit-（粘贴位）" class="headerlink" title="stick bit （粘贴位）"></a>stick bit （粘贴位）</h2><p>再看个实例，查看你的/tmp目录的权限</p>
<pre><code># ls -dl /tmp
drwxrwxrwt 6 root root 4096 08-22 11:37 /tmp</code></pre><p> tmp目录是所有用户共有的临时文件夹，所有用户都拥有读写权限，这就必然出现一个问题，A用户在/tmp里创建了文件a.file，此时B用户看了不爽，在/tmp里把它给删了（因为拥有读写权限），那肯定是不行的。实际上是不会发生这种情况，因为有特殊权限stick bit（粘贴位）权限，正如drwxrwxrwt中的最后一个t</p>
<p>stick bit (粘贴位)就是：除非目录的属主和root用户有权限删除它，除此之外其它用户不能删除和修改这个目录。</p>
<p>也就是说，在/tmp目录中，只有文件的拥有者和root才能对其进行修改和删除，其他用户则不行，避免了上面所说的问题产生。用途一般是把一个文件夹的的权限都打开，然后来共享文件，象/tmp目录一样。</p>
<h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>setuid：chmod u+s xxx</p>
<p>setgid: chmod g+s xxx</p>
<p>stick bit : chmod o+t xxx</p>
<p>或者使用八进制方式，在原先的数字前加一个数字，三个权限所代表的进制数与一般权限的方式类似，如下:</p>
<pre><code>suid   guid    stick bit

 1        1          1</code></pre><p>所以：suid的二进制串为：100，换算十进制为：4</p>
<p>guid的二进制串为:010,换算：2</p>
<p>stick bit 二进制串：001，换算：1</p>
<p>于是也可以这样设:setuid:chmod 4755 xxx</p>
<p>setgid:chmod 2755 xxx</p>
<p>stick bit:chmod 1755 xxx</p>
<p>最后，在一些文件设置了特殊权限后，字母不是小写的s或者t，而是大写的S和T，那代表此文件的特殊权限没有生效，是因为你尚未给它对应用户的x权限  </p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>setuid</tag>
        <tag>setgid</tag>
        <tag>stick bit</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器配置java web服务总结</title>
    <url>/ipfs/di-ci-pei-zhi-java-webfu-wu/</url>
    <content><![CDATA[<blockquote>
<p>首先，以前是写php的，从未接触java的开发。最近公司项目重组，被安排说去做java开发，而且要快速上手,安排培训，可是，培训的都是windows下的IDE开发配置。没办法，Google呗。这样就有了这篇东拼西奏的文章，也有自己的一些经验总结，没少碰壁，不过这里还是感谢同事的帮忙，让我对java的运行有了清晰的认识。</p>
</blockquote>
<h2 id="了解java包运行原理"><a href="#了解java包运行原理" class="headerlink" title="了解java包运行原理"></a>了解java包运行原理</h2><p>java是编译型语言，自然少不了打包，链接，当然这些都可以用maven来管理。用maven打包，链接生成的安装包就是可以直接使用java来运行的，我们这里主要说web服务的配置，所以少不了tomcat。使用tomcat来运行web项目包，就可以在浏览器端访问，java应用服务，这就是大致的过程。</p>
<h2 id="安装必要的软件包"><a href="#安装必要的软件包" class="headerlink" title="安装必要的软件包"></a>安装必要的软件包</h2><h3 id="安装jdk-至于安装哪个版本，视情况而定"><a href="#安装jdk-至于安装哪个版本，视情况而定" class="headerlink" title="安装jdk,至于安装哪个版本，视情况而定"></a>安装jdk,至于安装哪个版本，视情况而定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S jdk8-openjdk</span><br></pre></td></tr></table></figure>
<p>可以搜索一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Ss java</span><br></pre></td></tr></table></figure>

<h3 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S maven</span><br></pre></td></tr></table></figure>

<p>以上安装成功了以后，我们就可以使用<code>java, mvn</code> 的命令了，由于我们使用的是pacman安装方法，必要的环境变量都已经默认好了，可以不需要配置，具体可以看我以前写的 <a href="http://www.hcaijin.com/java-xue-xi-bi-ji/" target="_blank" rel="noopener">Java 学习笔记1</a></p>
<h3 id="安装tomcat，同样的源里也有多个版本，视情况安装相应的版本"><a href="#安装tomcat，同样的源里也有多个版本，视情况安装相应的版本" class="headerlink" title="安装tomcat，同样的源里也有多个版本，视情况安装相应的版本"></a>安装tomcat，同样的源里也有多个版本，视情况安装相应的版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S tomcat7</span><br></pre></td></tr></table></figure>

<h2 id="tomcat-主要配置详解"><a href="#tomcat-主要配置详解" class="headerlink" title="tomcat 主要配置详解"></a>tomcat 主要配置详解</h2><h3 id="主要目录功能"><a href="#主要目录功能" class="headerlink" title="主要目录功能"></a>主要目录功能</h3><p>默认情況 tomcat7 安装路径为 /usr/share/tomcat7，这里罗列一下主要目录的作用：</p>
<ul>
<li>/usr/share/tomcat7： 程序的主目录，也是变量 $CATALINA_HOME 所指向的位置，在单 tomcat 实例的情況下，也是变量 $CATALINA_BASE 所指向的位置。</li>
<li>/usr/share/tomcat7/bin： 程序的执行脚本目录</li>
<li>conf -&gt; /etc/tomcat7： 配置文档目录，存放主要是配置信息。</li>
<li>lib -&gt; /usr/share/java/tomcat7： 共用jar包目录，这些包即给 tomcat 使用，也能给 web 应用程序所调用。</li>
<li>logs -&gt; /var/log/tomcat7： 日志目录，对于查找错误以及查看访问记录很有用。</li>
<li>webapps -&gt; /var/lib/tomcat7/webapps： 默认的 web 应用程序目录，tomcat7 自带了几个示例应用。</li>
</ul>
<h3 id="启动关闭脚本"><a href="#启动关闭脚本" class="headerlink" title="启动关闭脚本"></a>启动关闭脚本</h3><p>我们进入程序执行脚本目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;share&#x2F;tomcat7 </span><br><span class="line">sudo .&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p>以上，tomcat服务就启动成功了，可以在浏览器中访问<code>http://localhost:8080</code> ，如果看到 tomcat 猫即说明服务已经安装成功并且能正常运行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;shutdown.sh</span><br></pre></td></tr></table></figure>
<p>这两个脚本都是通过调用 catalina.sh 来执行的，具体自己看脚本代码。</p>
<h2 id="实例讲解tomcat启动java应用"><a href="#实例讲解tomcat启动java应用" class="headerlink" title="实例讲解tomcat启动java应用"></a>实例讲解tomcat启动java应用</h2><p>这里我犯了一个错误，总以为java应用之前总得有个相互调用的关系，没想到其实都已经在maven打包，安装到本地就行了，web应用配置好相应的pom.xml就可以调用maven打包，安装好的后台java应用。</p>
<p>然后，我们开始说明代码部署过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;app&#x2F;                             ###进入工程主目录</span><br><span class="line">git clone git@erp:ecerp-saas              ###从erp服务器拉代码到本地</span><br><span class="line">cd &#x2F;data&#x2F;app&#x2F;ecerp-saas&#x2F;                  ###进入代码目录</span><br><span class="line">git pull                                  ###这个是同步服务器代码</span><br><span class="line">cd &#x2F;data&#x2F;app&#x2F;ecerp-saas&#x2F;Sources&#x2F;ecerp     ###进到主要工程目录</span><br><span class="line">mvn  clean install -Dmaven.test.skip&#x3D;true ###打包安装工程目录下相应的程序，这样就会编译好应用到本地用户目录下&#96;~&#x2F;.m2&#x2F;&#96;</span><br></pre></td></tr></table></figure>
<p>在web目录下新建目录erp.hcj.com</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;www&#x2F;</span><br><span class="line">mkdir erp.hcj.com&#x2F;</span><br><span class="line">cd erp.hcj.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>web应用java环境变量配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch webconfig</span><br><span class="line">cat webconfig</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2016/01/--_2016-01-25_17-47-28.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;data&#x2F;www&#x2F;erp.hcj.com&#x2F;webconfig     ###使用环境变量生效</span><br></pre></td></tr></table></figure>
<p>创建备份目录,当然这个不是必要的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theday&#x3D;$(date +%Y%m%d)</span><br><span class="line">releaseDir&#x3D;&quot;&#x2F;data&#x2F;deployment&#x2F;packages&#x2F;$&#123;theday&#125;&quot;</span><br><span class="line">if [ ! -e $releaseDir ]</span><br><span class="line">then</span><br><span class="line">       mkdir -p $releaseDir</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以到java应用安装目录下找packagename，把它移到备份目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -fp &#96;find ~&#x2F;.m2&#x2F;repository&#x2F; -name $packagename&#96; $releaseDir&#x2F;$packagename</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#备份数据</span><br><span class="line">bktime&#x3D;$(date +%y%m%d%H%M)</span><br><span class="line">backupdir&#x3D;&quot;&#x2F;data&#x2F;deployment&#x2F;release-backup&#x2F;$bktime&#x2F;$(basename $srvdir)&quot;</span><br><span class="line">if [ ! -e $backupdir ]</span><br><span class="line">then</span><br><span class="line">    mkdir -p $backupdir</span><br><span class="line">fi</span><br><span class="line">rootdir&#x3D;&#x2F;data&#x2F;www&#x2F;erp.hcj.com&#x2F;webroot</span><br><span class="line">for files in $(ls $rootdir)</span><br><span class="line">do</span><br><span class="line">    if [ $files &#x3D;&#x3D; &quot;upload&quot; ]; then</span><br><span class="line">    ¦   echo $files not backup</span><br><span class="line">    else</span><br><span class="line">    ¦   &#x2F;bin&#x2F;cp -rfp $rootdir&#x2F;$files $backupdir</span><br><span class="line">    fi  </span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 删除旧应用</span><br><span class="line">rm -rf $rootdir&#x2F;WEB-INF&#x2F;*</span><br><span class="line">### 解压文件，在web主目录下生成webroot</span><br><span class="line">packagefile&#x3D;$releaseDir&#x2F;$packagename</span><br><span class="line">tar zxf $packagefile -C &#x2F;data&#x2F;www&#x2F;erp.hcj.com</span><br><span class="line">### 修改webroot的权限</span><br><span class="line">chown tomcat7.tomcat7 -R &#x2F;data&#x2F;www&#x2F;erp.hcj.com&#x2F;webroot</span><br></pre></td></tr></table></figure>
<p>以上就基本是把java打包的应用程序，安装到了tomcat的webroot目录下了，但是要使这个应用启动成功，还需要配置多实例的tomcat的配置文件server.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;www&#x2F;erp.hcj.com</span><br><span class="line">mkdir -p tomcat&#x2F;&#123;conf,logs,tmp,work,&#125;</span><br><span class="line">cp -r &#x2F;etc&#x2F;tomcat7&#x2F;* tomcat&#x2F;conf&#x2F;</span><br><span class="line">sudo chown -R tomcat7.tomcat7 tomcat&#x2F;</span><br><span class="line">vi server.xml</span><br></pre></td></tr></table></figure>
<p>主要修改如下配置：<br><img data-src="/content/images/2016/01/--_2016-01-25_18-48-50.png" alt=""><br><img data-src="/content/images/2016/01/--_2016-01-25_18-49-35.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 设置tomcat环境变量</span><br><span class="line">export CATALINA_HOME&#x3D;&quot;&#x2F;usr&#x2F;share&#x2F;tomcat7&quot;</span><br><span class="line">export DUSER&#x3D;&quot;tomcat7&quot;</span><br><span class="line">export CATALINA_BASE&#x3D;&quot;&#x2F;data&#x2F;www&#x2F;erp.hcj.com&#x2F;tomcat&quot;</span><br><span class="line">export CATALINA_PID&#x3D;&quot;$CATALINA_BASE&#x2F;tomcat.pid&quot;</span><br><span class="line">export CATALINA_TMPDIR&#x3D;&quot;$CATALINA_BASE&#x2F;tmp&quot;</span><br><span class="line">export CATALINA_OUT&#x3D;&quot;$CATALINA_BASE&#x2F;logs&#x2F;catalina.out&quot;                                                                                                                                                                            </span><br><span class="line">export LOCKFILE&#x3D;&quot;$CATALINA_BASE&#x2F;tomcat.lock&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 启动服务</span><br><span class="line">&#x2F;bin&#x2F;bash $CATALINA_HOME&#x2F;bin&#x2F;startup.sh</span><br><span class="line">### 关闭服务</span><br><span class="line">&#x2F;bin&#x2F;bash $CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh</span><br></pre></td></tr></table></figure>

<p><a href="http://ufaw0116.erufa.com/wordpress/?p=1254&ckattempt=3" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL导入导出csv文件命令行操作</title>
    <url>/ipfs/mysqldao-ru-dao-chu-csvwen-jian-ming-ling-xing-cao-zuo/</url>
    <content><![CDATA[<p>1、先确认一下cvs的文件格式，确保与表编码一至。设为utf8<br>2、创建表，设置为utf8<br>3、登陆mysql, 导入csv文件</p>
<pre><code>$ mysql -uroot -p
MariaDB []&gt; create database test; use test;
MariaDB [test]&gt; LOAD DATA INFILE &apos;/mysql/test_data.csv&apos; REPLACE INTO TABLE test_table CHARACTER SET utf8 FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\r\n&apos;;</code></pre><p>注意：test_data.csv 要在mysql 的用户权限中，即使放到/tmp 目录下也是有问题的，暂时不知道怎么解决。</p>
<pre><code>$ sudo mkdir /mysql ; 
$ sudo chown -R mysql.mysql /mysql 
$ sudo cp ~/test_data.csv /mysql/</code></pre>]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>csv</tag>
        <tag>utf8</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统挂载NTFS移动硬盘</title>
    <url>/ipfs/linuxxi-tong-gua-zai-ntfsyi-dong-ying-pan/</url>
    <content><![CDATA[<blockquote>
<p>工作中，同事之间拷贝数据的时候，由于我用的linux系统无法识别同事的NTFS移动硬盘，这才网上查了一下，原来还得安装一个软件，以下是<a href="http://www.cnblogs.com/kerrycode/archive/2013/04/01/2993701.html" target="_blank" rel="noopener">转载</a>的文章,记录一下。</p>
</blockquote>
<hr>
<p>有时候做大数据量迁移时，为了快速迁移大数据，有可能在Linux服务器上临时挂载NTFS格式的移动硬盘， 一般情况下，Linux是识别不了NTFS格式移动硬盘的（需要重编译Linux核心才能，加挂NTFS分区），这时候为了能让Linux服务器能够识别NTFS的移动硬盘，就必须安装ntfs-3g（Third Generation Read/Write NTFS Driver）的包。</p>
<hr>
<p>NTFS-3G介绍<br>NTFS-3G是一个开源项目，NTFS-3G是为Linux, Android, Mac OS X, FreeBSD, NetBSD, OpenSolaris, QNX, Haiku,和其他操作系统提供的一个稳定的，功能齐全，读写NTFS的驱动程序的。它提供了安全处理Windows XP，Windows Server 2003，Windows 2000，Windows Vista，Windows Server 2008和Windows 7操作系统下的NTFS文件系统。</p>
<p>NTFS-3g是一个开源软件，它支持在Linux下面读写NTFS格式的分区。它非常的快速，同时也很安全。它支持Windows 2000、XP、2003和Vista，并且支持所有的符合POSIX标准的磁盘操作。 ntfs-3g的目的是为了持续的发展，各硬件平台和操作系统的用户需要可靠的互通与支持ntfs的驱动，ntfs-3g可以提供可信任的、功能丰富的高性能解决方案。经过了12年多的发展，ntfs-3g已经逐渐稳定； </p>
<blockquote>
<p>资料介绍</p>
</blockquote>
<ul>
<li>官方网址：<a href="http://www.tuxera.com/，" target="_blank" rel="noopener">http://www.tuxera.com/，</a></li>
<li>文档手册：<a href="http://www.tuxera.com/community/ntfs-3g-manual/" target="_blank" rel="noopener">http://www.tuxera.com/community/ntfs-3g-manual/</a></li>
<li>下载地址：<a href="http://www.tuxera.com/community/ntfs-3g-download/" target="_blank" rel="noopener">http://www.tuxera.com/community/ntfs-3g-download/</a></li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="解压安装NTFS-3G。"><a href="#解压安装NTFS-3G。" class="headerlink" title="解压安装NTFS-3G。"></a>解压安装NTFS-3G。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvzf ntfs-3g_ntfsprogs-2012.1.15.tgz　　</span><br><span class="line">cd ntfs-3g_ntfsprogs-2012.1.15</span><br><span class="line">　　.&#x2F;configure </span><br><span class="line">　　make </span><br><span class="line">　　make install</span><br></pre></td></tr></table></figure>
<p><em>如果没有报错，提示安装成功，下面就可以用ntfs-3g来实现对NTFS分区的读写了</em></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配置挂载NTFS格式的移动硬盘"><a href="#配置挂载NTFS格式的移动硬盘" class="headerlink" title="配置挂载NTFS格式的移动硬盘"></a>配置挂载NTFS格式的移动硬盘</h4><h5 id="首先得到NTFS分区的信息"><a href="#首先得到NTFS分区的信息" class="headerlink" title="首先得到NTFS分区的信息"></a>首先得到NTFS分区的信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo fdisk -l | grep NTFS</span><br><span class="line">&#x2F;dev&#x2F;sdc1 * 1 244 1955776+ 7 HPFS&#x2F;NTFS</span><br></pre></td></tr></table></figure>

<h5 id="设置挂载点，用如下命令实现挂载"><a href="#设置挂载点，用如下命令实现挂载" class="headerlink" title="设置挂载点，用如下命令实现挂载"></a>设置挂载点，用如下命令实现挂载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t ntfs-3g &lt;NTFS Partition&gt; &lt;Mount Point&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如得到的NTFS分区信息为/dev/sdc1，挂载点设置在/mnt/usb下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mount -t ntfs-3g &#x2F;dev&#x2F;sdc1 &#x2F;mnt&#x2F;usb </span><br><span class="line">########## 或者直接用 #######</span><br><span class="line">$ ntfs-3g ntfs-3g &#x2F;dev&#x2F;sdc1 &#x2F;mnt&#x2F;usb</span><br></pre></td></tr></table></figure>

<h4 id="如果想实现开机自动挂载，可以在-etc-fstab里面添加如下格式语句"><a href="#如果想实现开机自动挂载，可以在-etc-fstab里面添加如下格式语句" class="headerlink" title="如果想实现开机自动挂载，可以在/etc/fstab里面添加如下格式语句"></a>如果想实现开机自动挂载，可以在/etc/fstab里面添加如下格式语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;NTFS Partition&gt; &lt;Mount Point&gt; ntfs-3g silent,umask&#x3D;0,locale&#x3D;zh_CN.utf8 0 0</span><br></pre></td></tr></table></figure>
<p>==这样可以实现NTFS分区里中文文件名的显示。 ==</p>
<p>　　</p>
<h3 id="卸载分区"><a href="#卸载分区" class="headerlink" title="卸载分区"></a>卸载分区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ umount &lt;NTFS Partition&gt; 　　</span><br><span class="line">##### 或者 #####</span><br><span class="line">$ umount &lt;Mount Point&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ntfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 设置大小写敏感</title>
    <url>/ipfs/mysql-she-zhi-da-xiao-xie-min-gan/</url>
    <content><![CDATA[<p>1、linux下mysql安装完后是默认：区分表名的大小写，不区分列名的大小写； </p>
<p>2、如何设置为不区分表名的大小写：<br>修改mysql配置文件/etc/mysql/my.cnf 中,在[mysqld]后添加lower_case_table_names=1，默认为0表示区分大小写，然后重启MYSQL服务。； </p>
<p>3、Mysql 在不同的操作系统中大小写敏感区别：<br>3.1、MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的： </p>
<ul>
<li>数据库名与表名是严格区分大小写的； </li>
<li>表的别名是严格区分大小写的； </li>
<li>列名与列的别名在所有的情况下均是忽略大小写的； </li>
<li>变量名也是严格区分大小写的； </li>
</ul>
<p>3.2、MySQL在Windows下都不区分大小写。 </p>
<p>4、如果想在查询时区分字段值的大小写，则：字段值需要设置BINARY属性，设置的方法有多种： </p>
<p>A、创建时设置：<br>CREATE TABLE T(<br>A VARCHAR(10) BINARY<br>); </p>
<p>B、使用alter修改：<br>ALTER TABLE <code>tablename</code> MODIFY COLUMN <code>cloname</code> VARCHAR(45) BINARY; </p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置博客ghost使用https 及安装StartSSL免费SSL证书</title>
    <url>/ipfs/nginxpei-zhi-https-ji-an-zhuang-startsslmian-fei-sslzheng-shu/</url>
    <content><![CDATA[<p>今天配置安装ssl证书碰到了不少的问题，这里记录一下。</p>
<blockquote>
<p>HTTP协议默认情况下是不加密的，各种密码，邮件的传输都是明文的，极有可能被互联网上的黑客给获取，造成隐私泄漏。<br>SSL是Secure Socket Layer的简称，具体的作用就是在部署了SSL证书的网站跟用户浏览器之间建立一个安全的会话。</p>
</blockquote>
<h3 id="nginx编译安装ssl模块"><a href="#nginx编译安装ssl模块" class="headerlink" title="nginx编译安装ssl模块"></a>nginx编译安装ssl模块</h3><p>在说安装证书之前，我先说一下，nginx 要想使用ssl需要在编译安装的时候加上配置参数 <code>--with-zlib=/data/nginx/lib/</code> 使用命令先看一下nginx配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V</span><br><span class="line">nginx version: nginx&#x2F;1.9.0</span><br><span class="line">built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) </span><br><span class="line">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>
<p>如果在configure arguments: 没有找到ssl相关模块，就得重新编译一下。找到nginx源码包，执行以下命令，如下：</p>
<p>==这里提醒一下，安装软件的时候我觉得还是在root权限下方便，而且可以避免不必要的无权限执行报错，即使有sudo的权限。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd nginx-1.9.0</span><br><span class="line">$ .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module   ##这里的stub模块是个统计性能用的，与本文无关，你也可以不安装这个。</span><br><span class="line">$ make     ##这里不要使用 make install，否则就覆盖安装了 make完之后在objs目录下就多了个nginx，这个就是新版本的程序了</span><br><span class="line">$ cp &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx.bak</span><br><span class="line">$ cp objs&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">$ &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V  ##这里就可以使用新版本的程序看一下编译参数里已经有ssl模块了。</span><br></pre></td></tr></table></figure>
<h3 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h3><p>这里说一下，免费的SSL与付费的SSL还是有区别的，我主要是为博客后台登陆使用SSL，学习配置一下。</p>
<p>StartCom公司是到目前止仅有的还提供免费SSL服务的公司（应该是吧，我也是听别人说的），支持多种浏览器的正常识别，只要通过他们的个人信息审核就可以免费使用一年的时间。我自己审核的时候，本想随便写个英文名称，地址，但是都被弊掉了。建议填写个人信息的时候还是要尽量真实。这样才能够一次性通过邮件审核。<br><a href="http://www.startssl.com/" target="_blank" rel="noopener">StartSSL官方首页</a> 具体申请流程我就不说了，打开官方网站看一下就知道了。</p>
<p>我们来说一下，安装的流程：<br>首先使用ssh登陆vps，执行如下命令生成证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl req -new -newkey rsa:2048 -nodes -out server.csr -keyout server.key</span><br></pre></td></tr></table></figure>
<p><img data-src="/content/images/2015/09/--_2015-09-14_00-06-53.png" alt=""></p>
<p>以上生成的server.csr 需要把内容粘贴到 StartSSL 去生成域名证书了。</p>
<p>这里生成的server.key 是没有passphrase的，所以这一节我们可以跳过不看。如果有配置密码的话，我们需要去掉private key的passphrase才能让Nginx自由自在的启动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp server.key server.key.bak</span><br><span class="line">$ sudo openssl rsa -in server.key.bak -out server.key</span><br></pre></td></tr></table></figure>

<h3 id="开始配置nginx"><a href="#开始配置nginx" class="headerlink" title="开始配置nginx"></a>开始配置nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line"></span><br><span class="line">    server_name hcaijin.com www.hcaijin.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http:&#x2F;&#x2F;127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;ssl&#x2F;hcjwebssl.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;ssl&#x2F;hcjnopassssl.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置把http的请求转到https</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    server_name hcaijin.com www.hcaijin.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http:&#x2F;&#x2F;127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #rewrite ^(.*) https:&#x2F;&#x2F;$server_name$1 permanent;</span><br><span class="line">	location ~ &#x2F;ghost(&#x2F;.*) &#123;</span><br><span class="line">		rewrite ^ https:&#x2F;&#x2F;$server_name$request_uri? permanent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#x2F;etc&#x2F;init.d&#x2F;nginx restart   ##重启一下nginx服务</span><br></pre></td></tr></table></figure>
<h3 id="解决Firefox浏览器不信任StartSSL免费SSL的问题"><a href="#解决Firefox浏览器不信任StartSSL免费SSL的问题" class="headerlink" title="解决Firefox浏览器不信任StartSSL免费SSL的问题"></a>解决Firefox浏览器不信任StartSSL免费SSL的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;cert.startssl.com&#x2F;certs&#x2F;ca.pem   </span><br><span class="line">$ wget http:&#x2F;&#x2F;cert.startssl.com&#x2F;certs&#x2F;sub.class1.server.ca.pem  </span><br><span class="line">$ sudo cat ca.pem sub.class1.server.ca.pem &gt;&gt; server.crt</span><br><span class="line">$ &#x2F;etc&#x2F;init.d&#x2F;nginx restart</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ghost</tag>
        <tag>openssl</tag>
        <tag>nginx</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 配置高并发</title>
    <url>/ipfs/nginx-pei-zhi-gao-bing-fa/</url>
    <content><![CDATA[<h2 id="一般来说nginx-配置文件中对优化比较有作用的为以下几项："><a href="#一般来说nginx-配置文件中对优化比较有作用的为以下几项：" class="headerlink" title="一般来说nginx 配置文件中对优化比较有作用的为以下几项："></a>一般来说nginx 配置文件中对优化比较有作用的为以下几项：</h2><ol>
<li>worker_processes 8;</li>
</ol>
<p>nginx 进程数，建议按照cpu 数目来指定，一般为它的倍数 (如,2个四核的cpu计为8)。</p>
<ol start="2">
<li>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</li>
</ol>
<p>为每个进程分配cpu，上例中将8 个进程分配到8 个cpu，当然可以写多个，或者将一<br>个进程分配到多个cpu。</p>
<ol start="3">
<li>worker_rlimit_nofile 65535;</li>
</ol>
<p>这个指令是指当一个nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文<br>件数（ulimit -n）与nginx 进程数相除，但是nginx 分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</p>
<p>现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</p>
<p>这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</p>
<p>查看linux系统文件描述符的方法：</p>
<p>[root@web001 ~]# sysctl -a | grep fs.file</p>
<p>fs.file-max = 789972</p>
<p>fs.file-nr = 510 0 789972</p>
<ol start="4">
<li>use epoll;</li>
</ol>
<p>使用epoll 的I/O 模型</p>
<p>(</p>
<p>补充说明:</p>
<p>与apache相类，nginx针对不同的操作系统，有不同的事件模型</p>
<pre><code>A）标准事件模型
 Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll
B）高效事件模型</code></pre><p>Kqueue：使用于 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X. 使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。<br>Epoll: 使用于Linux内核2.6版本及以后的系统。<br>/dev/poll：使用于 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</p>
<pre><code>Eventport：使用于 Solaris 10. 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</code></pre><p>)</p>
<ol start="5">
<li>worker_connections 65535;</li>
</ol>
<p>每个进程允许的最多连接数， 理论上每台nginx 服务器的最大连接数为worker_processes*worker_connections。</p>
<ol start="6">
<li>keepalive_timeout 60;</li>
</ol>
<p>keepalive 超时时间。</p>
<ol start="7">
<li>client_header_buffer_size 4k;</li>
</ol>
<p>客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</p>
<p>分页大小可以用命令getconf PAGESIZE 取得。</p>
<p>[root@web001 ~]# getconf PAGESIZE</p>
<p>4096</p>
<p>但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</p>
<ol start="8">
<li>open_file_cache max=65535 inactive=60s;</li>
</ol>
<p>这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。</p>
<ol start="9">
<li>open_file_cache_valid 80s;</li>
</ol>
<p>这个是指多长时间检查一次缓存的有效信息。</p>
<ol start="10">
<li>open_file_cache_min_uses 1;</li>
</ol>
<p>open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。</p>
<h2 id="关于内核参数的优化："><a href="#关于内核参数的优化：" class="headerlink" title="关于内核参数的优化："></a>关于内核参数的优化：</h2><p>net.ipv4.tcp_max_tw_buckets = 6000</p>
<p>timewait 的数量，默认是180000。</p>
<p>net.ipv4.ip_local_port_range = 1024 65000</p>
<p>允许系统打开的端口范围。</p>
<p>net.ipv4.tcp_tw_recycle = 1</p>
<p>启用timewait 快速回收。</p>
<p>net.ipv4.tcp_tw_reuse = 1</p>
<p>开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>开启SYN Cookies，当出现SYN 等待队列溢出时，启用cookies 来处理。</p>
<p>net.core.somaxconn = 262144</p>
<p>web 应用中listen 函数的backlog 默认会给我们内核参数的net.core.somaxconn 限制到128，而nginx 定义的NGX_LISTEN_BACKLOG 默认为511，所以有必要调整这个值。</p>
<p>net.core.netdev_max_backlog = 262144</p>
<p>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</p>
<p>net.ipv4.tcp_max_orphans = 262144</p>
<p>系统中最多有多少个TCP 套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS 攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</p>
<p>net.ipv4.tcp_max_syn_backlog = 262144</p>
<p>记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M 内存的系统而言，缺省值是1024，小内存的系统则是128。</p>
<p>net.ipv4.tcp_timestamps = 0</p>
<p>时间戳可以避免序列号的卷绕。一个1Gbps 的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</p>
<p>net.ipv4.tcp_synack_retries = 1</p>
<p>为了打开对端的连接，内核需要发送一个SYN 并附带一个回应前面一个SYN 的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK 包的数量。</p>
<p>net.ipv4.tcp_syn_retries = 1</p>
<p>在内核放弃建立连接之前发送SYN 包的数量。</p>
<p>net.ipv4.tcp_fin_timeout = 1</p>
<p>如 果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2 状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60 秒。2.2 内核的通常值是180 秒，3你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB 服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2 的危险性比FIN-WAIT-1 要小，因为它最多只能吃掉1.5K 内存，但是它们的生存期长些。</p>
<p>net.ipv4.tcp_keepalive_time = 30</p>
<p>当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时。</p>
<h2 id="下面贴一个完整的内核优化设置"><a href="#下面贴一个完整的内核优化设置" class="headerlink" title="下面贴一个完整的内核优化设置:"></a>下面贴一个完整的内核优化设置:</h2><p>vi /etc/sysctl.conf  CentOS5.5中可以将所有内容清空直接替换为如下内容:</p>
<p>net.ipv4.ip_forward = 0<br>net.ipv4.conf.default.rp_filter = 1<br>net.ipv4.conf.default.accept_source_route = 0<br>kernel.sysrq = 0<br>kernel.core_uses_pid = 1<br>net.ipv4.tcp_syncookies = 1<br>kernel.msgmnb = 65536<br>kernel.msgmax = 65536<br>kernel.shmmax = 68719476736<br>kernel.shmall = 4294967296<br>net.ipv4.tcp_max_tw_buckets = 6000<br>net.ipv4.tcp_sack = 1<br>net.ipv4.tcp_window_scaling = 1<br>net.ipv4.tcp_rmem = 4096 87380 4194304<br>net.ipv4.tcp_wmem = 4096 16384 4194304<br>net.core.wmem_default = 8388608<br>net.core.rmem_default = 8388608<br>net.core.rmem_max = 16777216<br>net.core.wmem_max = 16777216<br>net.core.netdev_max_backlog = 262144<br>net.core.somaxconn = 262144<br>net.ipv4.tcp_max_orphans = 3276800<br>net.ipv4.tcp_max_syn_backlog = 262144<br>net.ipv4.tcp_timestamps = 0<br>net.ipv4.tcp_synack_retries = 1<br>net.ipv4.tcp_syn_retries = 1<br>net.ipv4.tcp_tw_recycle = 1<br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_mem = 94500000 915000000 927000000<br>net.ipv4.tcp_fin_timeout = 1<br>net.ipv4.tcp_keepalive_time = 30<br>net.ipv4.ip_local_port_range = 1024 65000</p>
<p>使配置立即生效可使用如下命令：<br>/sbin/sysctl -p</p>
<h2 id="下面是关于系统连接数的优化"><a href="#下面是关于系统连接数的优化" class="headerlink" title="下面是关于系统连接数的优化"></a>下面是关于系统连接数的优化</h2><p>linux 默认值 open files 和 max user processes 为 1024</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure>

<p>1024</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit –u</span><br></pre></td></tr></table></figure>

<p>1024</p>
<p>问题描述： 说明 server 只允许同时打开 1024 个文件，处理 1024 个用户进程</p>
<p>使用ulimit -a 可以查看当前系统的所有限制值，使用ulimit -n 可以查看当前的最大打开文件数。</p>
<p>新装的linux 默认只有1024 ，当作负载较大的服务器时，很容易遇到error: too many open files 。因此，需要将其改大。</p>
<p>解决方法：</p>
<p>使用 ulimit –n 65535 可即时修改，但重启后就无效了。（注ulimit -SHn 65535 等效 ulimit -n 65535 ，-S 指soft ，-H 指hard)</p>
<p>有如下三种修改方式：</p>
<ol>
<li>在/etc/rc.local 中增加一行 ulimit -SHn 65535</li>
<li>在/etc/profile 中增加一行 ulimit -SHn 65535</li>
<li>在/etc/security/limits.conf 最后增加：</li>
</ol>
<ul>
<li>soft nofile 65535</li>
<li>hard nofile 65535</li>
<li>soft nproc 65535</li>
<li>hard nproc 65535</li>
</ul>
<p>具体使用哪种，在 CentOS 中使用第1 种方式无效果，使用第3 种方式有效果，而在Debian 中使用第2 种有效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure>

<p>65535</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -u</span><br></pre></td></tr></table></figure>

<p>65535</p>
<p>备注：ulimit 命令本身就有分软硬设置，加-H 就是硬，加-S 就是软默认显示的是软限制</p>
<p>soft 限制指的是当前系统生效的设置值。 hard 限制值可以被普通用户降低。但是不能增加。 soft 限制不能设置的比 hard 限制更高。 只有 root 用户才能够增加 hard 限制值。</p>
<h2 id="下面是一个简单的nginx-配置文件："><a href="#下面是一个简单的nginx-配置文件：" class="headerlink" title="下面是一个简单的nginx 配置文件："></a>下面是一个简单的nginx 配置文件：</h2><p>user www www;<br>worker_processes 8;<br>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000<br>01000000;<br>error_log /www/log/nginx_error.log crit;<br>pid /usr/local/nginx/nginx.pid;<br>worker_rlimit_nofile 204800;<br>events<br>{<br>use epoll;<br>worker_connections 204800;<br>}<br>http<br>{<br>include mime.types;<br>default_type application/octet-stream;<br>charset utf-8;<br>server_names_hash_bucket_size 128;<br>client_header_buffer_size 2k;<br>large_client_header_buffers 4 4k;<br>client_max_body_size 8m;<br>sendfile on;<br>tcp_nopush on;<br>keepalive_timeout 60;<br>fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2<br>keys_zone=TEST:10m<br>inactive=5m;<br>fastcgi_connect_timeout 300;<br>fastcgi_send_timeout 300;<br>fastcgi_read_timeout 300;<br>fastcgi_buffer_size 4k;<br>fastcgi_buffers 8 4k;<br>fastcgi_busy_buffers_size 8k;<br>fastcgi_temp_file_write_size 8k;<br>fastcgi_cache TEST;<br>fastcgi_cache_valid 200 302 1h;<br>fastcgi_cache_valid 301 1d;<br>fastcgi_cache_valid any 1m;<br>fastcgi_cache_min_uses 1;<br>fastcgi_cache_use_stale error timeout invalid_header http_500;<br>open_file_cache max=204800 inactive=20s;<br>open_file_cache_min_uses 1;<br>open_file_cache_valid 30s;<br>tcp_nodelay on;<br>gzip on;<br>gzip_min_length 1k;<br>gzip_buffers 4 16k;<br>gzip_http_version 1.0;<br>gzip_comp_level 2;<br>gzip_types text/plain application/x-javascript text/css application/xml;<br>gzip_vary on;<br>server<br>{<br>listen 8080;<br>server_name backup.aiju.com;<br>index index.php index.htm;<br>root /www/html/;<br>location /status<br>{<br>stub_status on;<br>}<br>location ~ .<em>.(php|php5)?$<br>{<br>fastcgi_pass 127.0.0.1:9000;<br>fastcgi_index index.php;<br>include fcgi.conf;<br>}<br>location ~ .</em>.(gif|jpg|jpeg|png|bmp|swf|js|css)$<br>{<br>expires 30d;<br>}<br>log_format access ‘$remote_addr – $remote_user [$time_local] “$request” ‘<br>‘$status $body_bytes_sent “$http_referer” ‘<br>‘“$http_user_agent” $http_x_forwarded_for’;<br>access_log /www/log/access.log access;<br>}<br>}</p>
<h2 id="关于FastCGI-的几个指令："><a href="#关于FastCGI-的几个指令：" class="headerlink" title="关于FastCGI 的几个指令："></a>关于FastCGI 的几个指令：</h2><p>fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10minactive=5m;</p>
<p>这个指令为FastCGI 缓存指定一个路径，目录结构等级，关键字区域存储时间和非活动删除时间。</p>
<p>fastcgi_connect_timeout 300;</p>
<p>指定连接到后端FastCGI 的超时时间。</p>
<p>fastcgi_send_timeout 300;</p>
<p>向FastCGI 传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI 传送请求的超时时间。</p>
<p>fastcgi_read_timeout 300;</p>
<p>接收FastCGI 应答的超时时间，这个值是指已经完成两次握手后接收FastCGI 应答的超时时间。</p>
<p>fastcgi_buffer_size 4k;</p>
<p>指定读取FastCGI 应答第一部分需要用多大的缓冲区，一般第一部分应答不会超过1k，由于页面大小为4k，所以这里设置为4k。</p>
<p>fastcgi_buffers 8 4k;</p>
<p>指定本地需要用多少和多大的缓冲区来缓冲FastCGI 的应答。</p>
<p>fastcgi_busy_buffers_size 8k;</p>
<p>这个指令我也不知道是做什么用，只知道默认值是fastcgi_buffers 的两倍。</p>
<p>fastcgi_temp_file_write_size 8k;</p>
<p>在写入fastcgi_temp_path 时将用多大的数据块，默认值是fastcgi_buffers 的两倍。</p>
<p>fastcgi_cache TEST</p>
<p>开启FastCGI 缓存并且为其制定一个名称。个人感觉开启缓存非常有用，可以有效降低CPU 负载，并且防止502 错误。</p>
<p>fastcgi_cache_valid 200 302 1h;<br>fastcgi_cache_valid 301 1d;<br>fastcgi_cache_valid any 1m;</p>
<p>为指定的应答代码指定缓存时间，如上例中将200，302 应答缓存一小时，301 应答缓存1 天，其他为1 分钟。</p>
<p>fastcgi_cache_min_uses 1;</p>
<p>缓存在fastcgi_cache_path 指令inactive 参数值时间内的最少使用次数，如上例，如果在5 分钟内某文件1 次也没有被使用，那么这个文件将被移除。</p>
<p>fastcgi_cache_use_stale error timeout invalid_header http_500;</p>
<p>不知道这个参数的作用，猜想应该是让nginx 知道哪些类型的缓存是没用的。以上为nginx 中FastCGI 相关参数，另外，FastCGI 自身也有一些配置需要进行优化，如果你使用php-fpm 来管理FastCGI，可以修改配置文件中的以下值：</p>
<p><value name="max_children">60</value></p>
<p>同时处理的并发请求数，即它将开启最多60 个子线程来处理并发连接。</p>
<p><value name="rlimit_files">102400</value></p>
<p>最多打开文件数。</p>
<p><value name="max_requests">204800</value></p>
<p>每个进程在重置之前能够执行的最多请求数。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus6p虚焊导致无限重启之救砖教程</title>
    <url>/ipfs/bootlooping-nexus6p-fix/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>前两天手机在使用过程中，无故死机，重启发现在logo显示画面停留一会儿又重启，后面就一直不断的循环这个过程。<br>本来以为重新做系统就好了，没想到再还原回去还是一样。我以为就这么变砖了，最后还是因为穷的力量，搜索nexus6p无限重启原因就发现原来这是由于前几天我手机摔过一次，可能导致cpu虚焊部分出了毛病，才导致现在手机无限重启的情况。<br>没办法，通过这几天各种google，终于找到网络上很多大神都有解决的方案，后面后提供大神帖子链接。</p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>备份当前的文件和数据</li>
<li>在手机上启用USB调试和OEM解锁</li>
<li>下载<a href="https://developer.android.com/studio/releases/platform-tools.html" target="_blank" rel="noopener">ADB驱动程序</a>，安装到你的PC机里。这里有个问题，要安装低版本的，大于29.0的版本再使用时报了个错误,提示找不到可用的命令，网上解决方法就是下载安装26.0版本的解决了这个问题。</li>
<li>去这里<a href="https://twrp.me/Devices/" target="_blank" rel="noopener">下载</a>符合nexus6p的TWRP，这里我下载了3.3.1版本的</li>
<li>去magisk官网下载最新版本应用包括manage</li>
<li>下载要用到的刷机固件<a href="https://androidfilehost.com/?w=files&flid=302684" target="_blank" rel="noopener">Lineage OS</a>，<a href="https://developers.google.com/android/ota#angler" target="_blank" rel="noopener">原厂镜像 Nexus6p</a></li>
<li>下载我打包的要用到的boot.img</li>
</ul>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><blockquote>
<p>由于已经进入不了系统了，备份需要链接USB进到REF里使用这个方法<code>adb pull sdcard</code>备份自己重要的数据</p>
</blockquote>
<h1 id="开始刷系统"><a href="#开始刷系统" class="headerlink" title="开始刷系统"></a>开始刷系统</h1><blockquote>
<p>这里要提一点，一开始我找到的方法是刷指定原厂镜像，刷写4核boot.img就可以重新进入系统。后面又找到不一定原厂镜像的版本，比如lingage17.1的镜像也可以通过大神的方法。<br>所以，这两种方法都可以解决无限重启进不了系统的问题，我都写在这里，只要看一种方法就好了。</p>
</blockquote>
<h2 id="第一种方法：刷原厂镜像"><a href="#第一种方法：刷原厂镜像" class="headerlink" title="第一种方法：刷原厂镜像"></a>第一种方法：刷原厂镜像</h2><blockquote>
<p>先说一下刷原厂镜像7.1.2版本号n2g48c,<a href="https://bbs.gfan.com/android-9270440-1-1.html" target="_blank" rel="noopener">参考文档</a>,<a href="https://forum.xda-developers.com/nexus-6p/general/guide-fix-nexus-6p-bootloop-death-blod-t3640279" target="_blank" rel="noopener">英文原档</a></p>
</blockquote>
<ul>
<li>具体怎么刷参考文档里已经写得很清楚了，主要说一下，如果没有刷过twrp的先刷这个<code>fastboot flash recovery twrp3_1_1_4Cores.img</code></li>
<li>先线刷7.1.2, 具体线刷的操作，即进入TWRP界面，选Advanced再点sideload，滑块确认，等待pc端执行<code>adb sideload angler-ota-n2g48c-b004b71e.zip</code></li>
<li>接下来刷入修改版本的boot:<code>adb flash boot 6p48C.img</code></li>
<li>如果前面你先刷twrp就不用再刷一次了。</li>
<li>最后就是进入twrp卡刷性能包6pEX4_1_2.zip。具体操作：把zip包上传到手机sdcard,在twrp界面选择install指定的zip包安装，一路下一步就可以了。如果需要优化就得自己研究其他选项了。</li>
<li>以上就可以完美开机了。</li>
</ul>
<h2 id="第二种方法：刷第三方镜像lineage-17-1"><a href="#第二种方法：刷第三方镜像lineage-17-1" class="headerlink" title="第二种方法：刷第三方镜像lineage 17.1"></a>第二种方法：刷第三方镜像lineage 17.1</h2><blockquote>
<p>理论上刷其他所有的镜像都可以使用这个方法重进系统。<a href="https://forum.xda-developers.com/nexus-6p/general/bootloop-death-blod-workaround-zip-t3819515" target="_blank" rel="noopener">参考文档</a></p>
</blockquote>
<ul>
<li>下载重要的改写cpu核心的软件<a href="https://androidfilehost.com/?w=files&flid=312881" target="_blank" rel="noopener">N5x-6P_BLOD_Workaround_Injector_Addon-AK3-signed</a></li>
<li>USB链接手机，使用命令<code>adb reboot bootloader</code>重启</li>
<li>进入原先系统已经刷过twrp的可以直接进入twrp线刷lineage 17.1<code>adb sideload lineage-17.1-20200308-UNOFFICIAL-angler.zip</code> <a href="https://forum.xda-developers.com/nexus-6p/orig-development/rom-lineageos-17-0-nexus-6p-angler-t4012099" target="_blank" rel="noopener">参考文档</a></li>
<li>刷写twrp <code>fastboot flash recovery twrp-3.3.1-0-fbe-4core-angler.img</code></li>
<li>然后进入REC模式，上传zip包到sdcard,线刷Addon-AK3.signed.zip这个包<code>adb sideload N5X-6P_BLOD_Workaround_Injector_Addon-AK3-signed.zip</code></li>
<li>最后重启，等待一会儿就可以进入系统了。</li>
</ul>
<h3 id="解决指纹功能bug问题"><a href="#解决指纹功能bug问题" class="headerlink" title="解决指纹功能bug问题"></a>解决指纹功能bug问题</h3><blockquote>
<p>就上一篇文章，我再刷PixelExperience时已经提到过，使用magisk安装补丁的方法重新刷boot就好了。<a href="https://topjohnwu.github.io/Magisk/install.html" target="_blank" rel="noopener">参考文档</a></p>
</blockquote>
<ul>
<li>上传boot-17.img到手机<code>adb push boot-17.img sdcard/</code></li>
<li>在手机里安装最新版本的magisk manager</li>
<li>打开magisk点击安装-&gt;安装-&gt;选择要安装的boot-17.img</li>
<li>magisk manager 将生成新的文件magisk_patched.img到sdcard/Download/</li>
<li>下载这个补丁到PC机<code>adb pull /sdcard/Download/magisk_patche.img</code></li>
<li>最后重启进入bootloader刷写这个补丁<code>fastboot flash boot magisk_patched.img</code></li>
<li>以上完成就可以重进系统使用指纹的功能了。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>其实这两个方法最主要是线刷的zip包不同，第二种方法里的AK3包实现了任何系统修改cpu4核心的方法。</p>
</blockquote>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><blockquote>
<p>我打包了一下所有要用到的软件（不包括原厂镜像包，这些都可以去官网下载)，防止原链接失效。<a href="https://drive.google.com/file/d/1Bd4nASTMve23qh28x3BR3OJWJp2NZJyI/view?usp=sharing" target="_blank" rel="noopener">备份包</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>bootloop</tag>
        <tag>nexus6p</tag>
        <tag>android</tag>
        <tag>magisk</tag>
      </tags>
  </entry>
  <entry>
    <title>PPTP 服务器端安装与配置详解</title>
    <url>/ipfs/pptp-fu-wu-qi-duan-an-zhuang-yu-pei-zhi-xiang-jie/</url>
    <content><![CDATA[<h2 id="安装前环境检查"><a href="#安装前环境检查" class="headerlink" title="安装前环境检查"></a>安装前环境检查</h2><p>因为pptp需要MPPE的支持，所以首先检测系统是否符已经编译了MPPE。<br>下面介绍两种检测方法，只要符合其中的一条就可以</p>
<h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><pre><code># zgrep MPPE /proc/config.gz
CONFIG_PPP_MPPE=y
# cat /dev/net/tun
cat: /dev/net/tun: File descriptor in bad state</code></pre><h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><p>网上大多数资料还提到了另一个测试命令</p>
<pre><code>$ modprobe ppp-compress-18 &amp;&amp; echo ok
FATAL: Module ppp_mppe not found. </code></pre><p>如果返回“OK”说明可以安装PPTP，我查了一下，这个命令是在CentOS 4.4版本中有人提出的，但是经过实际测试，发现在我的环境中非但没有效果，而且报错。<br>所以<strong>如果modprobe ppp-compress-18 &amp;&amp; echo ok没有显示“OK”甚至报错，并不代表不能安装</strong>。最好还是用上面那种方法查看。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>由于pptp需要iptables支持，所以需要安装iptables。如果您的服务器上已经安装了iptables，那么可以只安装pptp</p>
<pre><code>$ yum install -y ppp iptables</code></pre><p>注意：这里先安装的是ppp而不是pptp，不要打错了。另：PPP是一种数据链路层协议类似我们熟知的pppoe<br>接下来就是一大堆的信息，无非是寻找最快的源，找到后下载相关安装包，下载完成自动安装。<br>如果回到提示符状态，并且安装结果为Complete!，说明安装成功。</p>
<h2 id="安装pptp"><a href="#安装pptp" class="headerlink" title="安装pptp"></a>安装pptp</h2><p>现在我们可以正式安装VPN Server了。这里我们选择pptp(VPN 协议的一种),因为简单，一条命令搞定。剩下的无非是一些配置。<br>    yum -y install pptpd</p>
<h3 id="配置pptp"><a href="#配置pptp" class="headerlink" title="配置pptp"></a>配置pptp</h3><h4 id="编辑-etc-ppp-options-pptpd"><a href="#编辑-etc-ppp-options-pptpd" class="headerlink" title="编辑/etc/ppp/options.pptpd"></a>编辑/etc/ppp/options.pptpd</h4><p>pptpd安装完成后，编辑/etc/pptpd.conf文件，去掉下面两行的注释或者直接添加这两行(在文件的最后).这一步是配置ip地址的范围。</p>
<p>localip 192.168.0.1<br>remoteip 192.168.0.100-150</p>
<h4 id="设置使用pptp的用户名和密码"><a href="#设置使用pptp的用户名和密码" class="headerlink" title="设置使用pptp的用户名和密码"></a>设置使用pptp的用户名和密码</h4><p>然后在/etc/ppp/chap-secrets文件中添加VPN用户，按照下面的格式,每个用户一行。</p>
<p>username pptpd password *</p>
<h4 id="配置DNS服务器"><a href="#配置DNS服务器" class="headerlink" title="配置DNS服务器"></a>配置DNS服务器</h4><p>为了让你的用户连上VPN后能够正常地解析域名，我们需要手动设置DNS. 编辑/etc/ppp/options，找到ms-dns这一项，设置你的DNS.这里我推荐的是Google 最近发布的Public DNS,原因是因为好记。</p>
<p>ms-dns 8.8.8.8<br>ms-dns 209.244.0.3<br>ms-dns 208.67.222.222<br>ms-dns 8.8.4.4</p>
<h4 id="修改内核设置，使其支持转发。"><a href="#修改内核设置，使其支持转发。" class="headerlink" title="修改内核设置，使其支持转发。"></a>修改内核设置，使其支持转发。</h4><p>编辑/etc/sysctl.conf文件，找到”net.ipv4.ip_forward=1″这一行，去掉前面的注释并注释掉 “net.ipv4.tcp_syncookies=1”。</p>
<pre><code>net.ipv4.ip_forward=1
#net.ipv4.tcp_syncookies = 1</code></pre><p>运行下面的命令让配置生效。</p>
<pre><code>$ sysctl -p</code></pre><h2 id="iptables转发"><a href="#iptables转发" class="headerlink" title="iptables转发"></a>iptables转发</h2><pre><code>$ iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source 12.34.56.78</code></pre><p>(适合于OpenVZ架构的VPS,12.34.56.78为您VPS的公网IP地址)</p>
<pre><code>$ iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</code></pre><p>(适合于XEN架构的VPS)<br>以上两条命令分别对应OpenVZ架构和XEN架构的VPS，您的VPS是什么架构需要询问供应商。Linode采用的是XEN架构，所以输入</p>
<p>我的是搬瓦工的vps,配置如下：</p>
<pre><code>$ iptables -t nat -A POSTROUTING -o venet0 -s 192.168.0.0/24 -j SNAT  --to-source `ifconfig  | grep &apos;inet addr:&apos;| grep -v &apos;127.0.0.1&apos; | cut -d: -f2 | awk &apos;NR==1 { print $1}&apos;`</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;pptpd start</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pptp</tag>
        <tag>iptables</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI+GPT安装Archlinux与Win10双系统教程</title>
    <url>/ipfs/archlinux-uefi-bootloader/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近新入手一台Thinkpad,使用UEFI+GPT预安装好了Win10操作系统，准备开始安装Archlinux。</p>
</blockquote>
<p>如果你准备在一块新硬盘上安装双系统，那么应该先安装windows。<br>如果你安装的是Win10，那么它应该默认就是按UEFI+GPT方式安装的，可以按Win+X键打开磁盘管理，如果是UEFI安装的，那么应该有一个EFI分区，可能是250M。<br>其它还有Windows的恢复分区和基本数据分区。不用管恢复分区，如果现在磁盘上没有剩余空间，可以右键点击基本数据分区，点击压缩卷，给Arch的安装腾出空间。用右键点击磁盘，查看属性，可以知道自己是否采用了GPT分区方式。</p>
<p>在安装之前，请在电源计划中关掉Windows的快速启动，并在BIOS中关掉Secure Boot，可以很容易搜到对应自己电脑的具体方法。<br>如果上面有哪一条没有满足，请只看一看我遇到的问题，具体安装请再参考其它教程</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装之前"><a href="#安装之前" class="headerlink" title="安装之前"></a>安装之前</h2><ul>
<li>准备一个大于4G的U盘</li>
<li>安装镜像，可以从Arch Linux的<a href="www.archlinux.org">官方网站</a>下载</li>
</ul>
<h2 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h2><p>这里我只介绍linux系统下使用<code>dd</code>的方式，windows下面的方法可以看一下这个<a href="https://github.com/mytbk/Linux_Notes/blob/master/install/install-archlinux.md" target="_blank" rel="noopener">安装教程</a></p>
<p>插入U盘，查看U盘设备名,不需求挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsblk</span><br><span class="line">sudo dd if&#x3D;archlinux-2018.06.01-x86_64.iso of&#x3D;&#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure>
<p>这样，就制作好了U盘启动了，把U盘插入要安装的机子，配置BIOS通过U盘启动，就可以进入光盘引导的临时系统。</p>
<h2 id="选择镜像源"><a href="#选择镜像源" class="headerlink" title="选择镜像源"></a>选择镜像源</h2><p>Arch Linux是通过网络进行安装的，为了以更快的速度下载软件包，建议先配置镜像源。配置镜像源的方法是编辑/etc/pacman.d/mirrorlist这个文件，将想用的镜像源的放到第一个非井号开头的行即可。如下可将中科大镜像源作为首选镜像源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist</span><br><span class="line"># This is the USTC mirror</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch</span><br><span class="line"></span><br><span class="line"># and other mirrors</span><br><span class="line">## Score: 4.6, China</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.163.com&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>配置完成后可以执行pacman -Syy试一下，可以看一下pacman从镜像站下载文件的速度。</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><blockquote>
<p>我们前面提过已经默认有安装的Win10系统,使用<code>fdisk</code>可以看到已经有一个EFI分区为250M大小。因此不要单独为Linux分出EFI分区，因为要双系统启动的话应该把Win10的EFI分区挂载到/boot上。</p>
</blockquote>
<p>以下是我的硬盘分区情况,因为我还有一块硬盘用来挂载/home，所以我只要创建根分区和swap分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Device             Start       End   Sectors  Size Type</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p1      2048    534527    532480  260M EFI System</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p2    534528    567295     32768   16M Microsoft reserved</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p3    567296 254337023 253769728  121G Microsoft basic data</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p4 254337024 485023743 230686720  110G Linux filesystem</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p5 498069504 500117503   2048000 1000M Windows recovery environment</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p6 485023744 497606655  12582912    6G Linux swap</span><br></pre></td></tr></table></figure>

<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 &#x2F;dev&#x2F;nvme0n1p4</span><br><span class="line"></span><br><span class="line">mkswap &#x2F;dev&#x2F;nvme0n1p6</span><br><span class="line">swapon &#x2F;dev&#x2F;nvme0n1p6</span><br></pre></td></tr></table></figure>

<h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><p>首先，一定是先挂载/分区，再挂载其它分区。因为要使用双系统启动，所以即使没有分/boot分区，还是应该把windows的EFI分区挂载到/上。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;nvme0n1p4 &#x2F;mnt&#x2F;</span><br><span class="line">mkdir -p &#x2F;mnt&#x2F;boot</span><br><span class="line">mount &#x2F;dev&#x2F;nvme0n1p1 &#x2F;mnt&#x2F;boot</span><br></pre></td></tr></table></figure>

<h2 id="基本软件安装"><a href="#基本软件安装" class="headerlink" title="基本软件安装"></a>基本软件安装</h2><p>安装Arch Linux的软件很简单，执行下面这条命令就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacstrap &#x2F;mnt base base-devel</span><br></pre></td></tr></table></figure>

<h1 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h1><h2 id="创建fstab"><a href="#创建fstab" class="headerlink" title="创建fstab"></a>创建fstab</h2><p>生成一个fstab文件（使用-U或-L分别由UUID或标签定义）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genfstab -U &#x2F;mnt &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<h2 id="切换新系统"><a href="#切换新系统" class="headerlink" title="切换新系统"></a>切换新系统</h2><p>现在我们执行<code>arch-chroot /mnt</code>，这样就以chroot的方式进入了新的系统。</p>
<h2 id="配置时间"><a href="#配置时间" class="headerlink" title="配置时间"></a>配置时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure>

<h2 id="配置本地化"><a href="#配置本地化" class="headerlink" title="配置本地化"></a>配置本地化</h2><p>在/etc/locale.gen中取消注释en_US.UTF-8 UTF-8和其他所需的本地化，并使用<code>local-gen</code>更新本地语言编码</p>
<h2 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;hcaijin.com&#39; &gt; &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure>
<h2 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<h2 id="设置启动"><a href="#设置启动" class="headerlink" title="设置启动"></a>设置启动</h2><p>按照上面的步骤，efi分区应该被挂载到了/boot目录下。这时，我们使用<code>bootctl install</code>命令，安装bootloader，然后用<code>cp /usr/share/systemd/bootctl/arch.conf /boot/loader/entries/</code>把示例文件复制过来，只要修改它的options部分就可以了。<br>以我的/boot分区为例，用<code>blkid -s PARTUUID -o value /dev/nvme0n1p1</code>就可以生成所需要的PARTUUID，最后加上rw就行了。 </p>
<p>格式大概为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title       Arch Linux</span><br><span class="line">linux       &#x2F;vmlinuz-linux</span><br><span class="line">initrd      &#x2F;initramfs-linux.img</span><br><span class="line">options     root&#x3D;UUID&#x3D;6278bd34-44cd-41b9-9bdd-239d9ce4020a rw</span><br></pre></td></tr></table></figure>
<p>意思是创建一个标题为Arch Linux的启动项，它用bootloader所在分区(/dev/sda1)根目录下的vmlinuz-linux作为Linux内核，initramfs-linux.img作为initramfs镜像(可以认为是一个临时rootfs镜像)，并且用root=/dev/sda2 ro作为内核参数。</p>
<p>再编辑/boot/loader/loader.conf.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 3</span><br><span class="line">default arch</span><br></pre></td></tr></table></figure>
<p>意思是默认用arch.conf的配置启动，等待3秒没有键盘操作即使用默认配置启动。</p>
<h2 id="新系统的网络"><a href="#新系统的网络" class="headerlink" title="新系统的网络"></a>新系统的网络</h2><p>启动盘中默认配置好了有关网络的软件，但新的系统中却没有。<br>如果你只是使用单一且固定的有线网络，使用<code>systemctl enable dhcpcd@interface.service</code>就可以了（interface是你的网络接口名，可以使用ip link查看，类似enp3s0）。<br>如果要使用无线网络，那么就要使用<code>pacman -S iw wpa_supplicant dialog</code>命令安装这些软件包。如果失败，可能要安装固件。</p>
<p>至此，新系统的配置就完成了。</p>
<p>使用exit命令退出chroot环境，umount -R /mnt卸载挂载的分区，然后使用reboot重启一下就好了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>可能会启动失败，解决方法是进入BIOS里的设置把UEFI作为唯一的启动方式。然后保存退出，就可以看到有三个启动项（分别是Arch Linux, Windows Manage, Default），选择你要进入的系统就可以了。</p>
]]></content>
      <tags>
        <tag>archlinux</tag>
        <tag>windows</tag>
        <tag>uefi</tag>
      </tags>
  </entry>
  <entry>
    <title>ghost 更新记录</title>
    <url>/ipfs/ghost-upgrade/</url>
    <content><![CDATA[<p>好久没有更新ghost 0.6.0，今天更新的时候发现最新版本，0.11.11 版本 更新安装的时候报错。</p>
<p>查看error日志，是依赖的npm和node版本问题。解决方法就是要么升级npm,node，要么降级ghost到npm,node支持的版本。</p>
<ul>
<li><p>升级npm,node在这里就不说了，网上有很多的方法，我用的是搬瓦工家的最便宜vps，使用的npm,node不好升级，估计还得升级linux内核，我就不打算使用这个方法了。</p>
</li>
<li><p>降级ghost到npm,node支持的版本。<br>我们到<a href="https://github.com/TryGhost/Ghost/releases" target="_blank" rel="noopener">Ghost各版本历史</a>去找一下历史版本，我尝试了几个版本，最后确定0.8.0这个版本是可以正常使用的。</p>
</li>
</ul>
<blockquote>
<p>这样我们就可以开始升级ghost了。升级ghost不需要停了当前的服务，但是，升级更新都要做好备份。</p>
</blockquote>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>登陆并进入https://$HOSTNAME/ghost/debug这个页面导出备份。</p>
<p>最好能登陆到服务器进入ghost安装的目录备份一下根目录下的content，这一步要先暂停服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;www&#x2F;ghost</span><br><span class="line">tar -zcvf ghost-content.tag content</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备份好以后，我们就可以删除与升级相关的目录了文件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf core&#x2F; node_modules&#x2F; index.js *.json</span><br></pre></td></tr></table></figure>

<h3 id="下载最新版本"><a href="#下载最新版本" class="headerlink" title="下载最新版本"></a>下载最新版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -LOk https:&#x2F;&#x2F;github.com&#x2F;TryGhost&#x2F;Ghost&#x2F;releases&#x2F;download&#x2F;0.8.0&#x2F;Ghost-0.8.0.zip</span><br></pre></td></tr></table></figure>
<p>然后解压到/data/www/ghost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">unzip -uo Ghost-0.8.0.zip -d &#x2F;data&#x2F;www&#x2F;ghost</span><br></pre></td></tr></table></figure>

<h3 id="安装并重启"><a href="#安装并重启" class="headerlink" title="安装并重启"></a>安装并重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm cache clear &amp;&amp; npm install --production</span><br></pre></td></tr></table></figure>
<p>没有报错的话就是安装成功了。</p>
<p>重启ghost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV&#x3D;production pm2 start index.js --name &quot;ghost&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ghost</tag>
      </tags>
  </entry>
  <entry>
    <title>git常规使用</title>
    <url>/ipfs/gitshi-yong/</url>
    <content><![CDATA[<h3 id="远程仓库有master和dev分支"><a href="#远程仓库有master和dev分支" class="headerlink" title="远程仓库有master和dev分支"></a>远程仓库有master和dev分支</h3><h4 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;git url&gt;</span><br></pre></td></tr></table></figure>

<h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --all</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认有了dev和master分支，所以会看到如下三个分支</p>
</blockquote>
<ul>
<li>master[本地主分支]</li>
<li>origin/master[远程主分支]</li>
<li>origin/dev[远程开发分支]</li>
</ul>
<p>==新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步，但是origin/dev分支在本地没有任何的关联，所以我们无法在那里开发==</p>
<h4 id="创建本地关联origin-dev的分支"><a href="#创建本地关联origin-dev的分支" class="headerlink" title="创建本地关联origin/dev的分支"></a>创建本地关联origin/dev的分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev origin&#x2F;dev</span><br></pre></td></tr></table></figure>

<p>创建本地分支dev，并且和远程origin/dev分支关联，本地dev分支的初始代码和远程的dev分支代码一样</p>
<h4 id="切换到dev分支进行开发"><a href="#切换到dev分支进行开发" class="headerlink" title="切换到dev分支进行开发"></a>切换到dev分支进行开发</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev  # 这个是切换到dev分支，然后就是常规的开发</span><br></pre></td></tr></table></figure>


<h3 id="假设远程仓库只有mater分支"><a href="#假设远程仓库只有mater分支" class="headerlink" title="假设远程仓库只有mater分支"></a>假设远程仓库只有mater分支</h3><h4 id="克隆代码-1"><a href="#克隆代码-1" class="headerlink" title="克隆代码"></a>克隆代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;git url&gt;</span><br></pre></td></tr></table></figure>

<h4 id="查看所有分支-1"><a href="#查看所有分支-1" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --all</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认只有master分支，所以会看到如下两个分支</p>
</blockquote>
<ul>
<li>master[本地主分支]</li>
<li>origin/master[远程主分支]</li>
</ul>
<p>==新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步==</p>
<h4 id="创建本地新的dev分支"><a href="#创建本地新的dev分支" class="headerlink" title="创建本地新的dev分支"></a>创建本地新的dev分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch dev  # 创建本地分支</span><br><span class="line">git branch  # 查看分支</span><br></pre></td></tr></table></figure>

<p>这时会看到master和dev，而且master上会有一个星号<br>这个时候dev是一个本地分支，远程仓库不知道它的存在<br>本地分支可以不同步到远程仓库，我们可以在dev开发，然后merge到master，使用master同步代码，当然也可以同步</p>
<h4 id="发布dev分支"><a href="#发布dev分支" class="headerlink" title="发布dev分支"></a>发布dev分支</h4><p>发布dev分支指的是同步dev分支的代码到远程服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin dev:dev  # 这样远程仓库也有一个dev分支了</span><br></pre></td></tr></table></figure>

<h4 id="在dev分支开发代码"><a href="#在dev分支开发代码" class="headerlink" title="在dev分支开发代码"></a>在dev分支开发代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev  # 切换到dev分支进行开发</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开发代码之后，我们有两个选择</p>
</blockquote>
<ul>
<li>第一个：如果功能开发完成了，可以合并主分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master  # 切换到主分支</span><br><span class="line">git merge dev  # 把dev分支的更改和master合并</span><br><span class="line">git push  # 提交主分支代码远程</span><br><span class="line">git checkout dev  # 切换到dev远程分支</span><br><span class="line">git push  # 提交dev分支到远程</span><br></pre></td></tr></table></figure>

<ul>
<li>第二个：如果功能没有完成，可以直接推送</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push  # 提交到dev远程分支</span><br></pre></td></tr></table></figure>

<p>== 注意：在分支切换之前最好先commit全部的改变，除非你真的知道自己在做什么 ==</p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin :dev  # 删除远程dev分支，危险命令哦</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面两条是删除本地分支</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master  # 切换到master分支</span><br><span class="line">git branch -d dev  # 删除本地dev分支</span><br></pre></td></tr></table></figure>
<h4 id="progit-pdf"><a href="#progit-pdf" class="headerlink" title="progit.pdf"></a>progit.pdf</h4><p>书籍格式和语言：中文、英文、PDF、ePub<br>下载地址：<a href="http://git-scm.com/book" target="_blank" rel="noopener">http://git-scm.com/book</a></p>
<p><a href="https://www.zhihu.com/question/21995370/answer/19975870" target="_blank" rel="noopener">转载</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>博客系统从ghost 迁移hexo 安装与配置</title>
    <url>/ipfs/hexo-install/</url>
    <content><![CDATA[<h1 id="备份Ghost"><a href="#备份Ghost" class="headerlink" title="备份Ghost"></a>备份Ghost</h1><p>后台export，导出后是一个JSON，包含所有文章以及一些元数据：修改日期、Tags 等等</p>
<p>图片等资源，可以到 assets 文件夹下，打包下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;www&#x2F;ghost</span><br><span class="line">tar -zcvf images.tag assets&#x2F;content</span><br></pre></td></tr></table></figure>

<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -S npm</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">cd &#x2F;data&#x2F;www&#x2F;</span><br><span class="line">hexo init hcaijin.com</span><br><span class="line">cd hcaijin.com</span><br><span class="line">hexo install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><h2 id="导入Ghost数据"><a href="#导入Ghost数据" class="headerlink" title="导入Ghost数据"></a>导入Ghost数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 安装数据转换插件</span><br><span class="line">npm install hexo-migrator-ghost --save</span><br><span class="line"></span><br><span class="line">## 导入数据</span><br><span class="line">hexo migrate ghost ghost-export.json</span><br></pre></td></tr></table></figure>

<h2 id="导入图片"><a href="#导入图片" class="headerlink" title="导入图片"></a>导入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp images.tag &#x2F;data&#x2F;www&#x2F;hcaijin.com&#x2F;source&#x2F;</span><br><span class="line">cd &#x2F;data&#x2F;www&#x2F;hcaijin.com&#x2F;source&#x2F;</span><br><span class="line">tar -zxvf images.tag</span><br></pre></td></tr></table></figure>

<h1 id="最后，做一些必要的配置"><a href="#最后，做一些必要的配置" class="headerlink" title="最后，做一些必要的配置"></a>最后，做一些必要的配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ul>
<li><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo 配置</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT 配置</a></li>
<li><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NexT 高级配置</a></li>
</ul>
<h2 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save                                                       </span><br><span class="line">npm install hexo-generator-sitemap --save                                                        </span><br><span class="line">npm install hexo-generator-feed --save                                                           </span><br><span class="line">npm install hexo-pwa --save                                                                      </span><br><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ghost</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Chromium OS源码编译、U盘安装及使用笔记</title>
    <url>/ipfs/chromium-os-install/</url>
    <content><![CDATA[<blockquote>
<p>根据官方文档 <a href="https://www.chromium.org/chromium-os/quick-start-guide" target="_blank" rel="noopener">https://www.chromium.org/chromium-os/quick-start-guide</a> 只有Ubuntu Trusty版本的安装方式写了个ArchLinux的安装方法</p>
</blockquote>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><ul>
<li>Arch Linux  4.16.12-1-ARCH</li>
<li>x86_64 GNU/Linux</li>
<li>有sudo权限的用户</li>
</ul>
<h2 id="基本依赖"><a href="#基本依赖" class="headerlink" title="基本依赖"></a>基本依赖</h2><p>确保有如下包就好了，没有就用<code>pacman -S</code> 安装就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S git-core gitk git-gui subversion curl lvm2 thin-provisioning-tools python-pkg-resources python-virtualenv python-oauth2client</span><br></pre></td></tr></table></figure>

<h2 id="安装depot-tools"><a href="#安装depot-tools" class="headerlink" title="安装depot_tools"></a>安装depot_tools</h2><p>用git克隆下来就好了,但要注意python的版本，后面会说.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Source&#x2F;</span><br><span class="line">git clone https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;tools&#x2F;depot_tools</span><br></pre></td></tr></table></figure>
<p>确保deport_tools目录在PATH变量里</p>
<h2 id="sudoers配置"><a href="#sudoers配置" class="headerlink" title="sudoers配置"></a>sudoers配置</h2><p>要设置Chrome操作系统构建环境，应该关闭sudo的tty_tickets选项，因为它与cros_sdk不兼容。执行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">cat &gt; .&#x2F;sudo_editor &lt;&lt;EOF</span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo Defaults \!tty_tickets &gt; \$1          # Entering your password in one shell affects all shells </span><br><span class="line">echo Defaults timestamp_timeout&#x3D;180 &gt;&gt; \$1 # Time between re-requesting your password, in minutes</span><br><span class="line">EOF</span><br><span class="line">chmod +x .&#x2F;sudo_editor </span><br><span class="line">sudo EDITOR&#x3D;.&#x2F;sudo_editor visudo -f &#x2F;etc&#x2F;sudoers.d&#x2F;relax_requirements</span><br></pre></td></tr></table></figure>

<h1 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h1><p>创建一个目录来保存源文件“${SOURCE_REPO}”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SOURCE_REPO&#x3D;&quot;~&#x2F;Source&#x2F;chromiumos&quot;</span><br><span class="line">mkdir $&#123;SOURCE_REPO&#125;</span><br><span class="line">cd $&#123;SOURCE_REPO&#125;</span><br><span class="line">virtualenv -p &#x2F;usr&#x2F;bin&#x2F;python2 venv			#这里我们要把python环境切换为2.7，才能使用下面的repo</span><br><span class="line">repo init -u https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromiumos&#x2F;manifest.git</span><br><span class="line"></span><br><span class="line"># Optional: Make any changes to .repo&#x2F;local_manifests&#x2F;local_manifest.xml before syncing</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<h1 id="创建chromiumos"><a href="#创建chromiumos" class="headerlink" title="创建chromiumos"></a>创建chromiumos</h1><h2 id="构建包"><a href="#构建包" class="headerlink" title="构建包"></a>构建包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export BOARD&#x3D;amd64-generic</span><br><span class="line">cros_sdk -- .&#x2F;build_packages --board&#x3D;$&#123;BOARD&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cros_sdk -- .&#x2F;build_image --board&#x3D;$&#123;BOARD&#125;</span><br></pre></td></tr></table></figure>

<h2 id="烧入USB"><a href="#烧入USB" class="headerlink" title="烧入USB"></a>烧入USB</h2><p>键入 <code>sudo fdisk -l</code> 查看插入U盘所在区域，然后执行如下操作烧录编译的系统到U盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cros_sdk -- cros flash usb:&#x2F;&#x2F;&#x2F;dev&#x2F;sdd ~&#x2F;chromiumos&#x2F;src&#x2F;build&#x2F;images&#x2F;amd-generic&#x2F;latest&#x2F;chromiumos_test_image.bin</span><br></pre></td></tr></table></figure>

<h2 id="修改分区"><a href="#修改分区" class="headerlink" title="修改分区"></a>修改分区</h2><p>如果要使用自定义大小容量的分区构建镜像，请考虑在 build_library/legacy_disk_layout.json 中添加新的磁盘布局或使用 adjust_part。请参阅下面的帮助，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adjust_part &#x3D;&#39;STATE：1G&#39; ---- 将1GB添加到状态分区</span><br><span class="line">adjust_part &#x3D;&#39;ROOT-A：-1G&#39; ---- 从主rootfs分区中删除1GB</span><br><span class="line">adjust_part &#x3D;&#39;STATE：&#x3D; 1G&#39; --- 设置状态分区为1GB</span><br></pre></td></tr></table></figure>
<p>这里键入 <code>cros_sdk -- ./build_image --board=${BOARD} --noenable_rootfs_verification test --adjust_part=&#39;STATE:+10G&#39;</code>，这样我们的Chromium OS用户空间便增加10G，如果使用默认设置你会发现用户空间容量不足（约140MB）</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>修改要安装到目标机器的bios启动项为U盘启动，插入U盘，启动。</p>
<p>进入系统，按Ctrl + Alt + Back（F2）。在提示符下输入chronos并使用以下命令进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;chromeos-install</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>archlinux</tag>
        <tag>ChromiumOS</tag>
      </tags>
  </entry>
  <entry>
    <title>idea tomcat 启动web应用异常处理</title>
    <url>/ipfs/idea-tomcat-qi-dong-webying-yong-yi-chang-chu-li/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-05-11 16:36:25.799 [RMI TCP Connection(4)-127.0.0.1] ERROR org.springframework.web.context.ContextLoader - Context initialization failed</span><br><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shiroFilter&#39; defined in file [&#x2F;home&#x2F;hcj&#x2F;Work&#x2F;data&#x2F;ecerp-saas&#x2F;Sources&#x2F;ecerp&#x2F;out&#x2F;artifacts&#x2F;ecerp_web_war_exploded&#x2F;WEB-INF&#x2F;classes&#x2F;spring&#x2F;applicationContext.xml]: Cannot resolve reference to bean &#39;securityManager&#39; while setting bean property &#39;securityManager&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;securityManager&#39; defined in file [&#x2F;home&#x2F;hcj&#x2F;Work&#x2F;data&#x2F;ecerp-saas&#x2F;Sources&#x2F;ecerp&#x2F;out&#x2F;artifacts&#x2F;ecerp_web_war_exploded&#x2F;WEB-INF&#x2F;classes&#x2F;spring&#x2F;applicationContext.xml]: Cannot resolve reference to bean &#39;shiroSubjectFactory&#39; while setting bean property &#39;subjectFactory&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;shiroSubjectFactory&#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private gy.erp.service.admin.SecurityMonitor gy.erp.shiro.ShiroSubjectFactory.securityMonitor; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;securityMonitor&#39; defined in class path resource [spring-domain.xml]: Cannot resolve reference to bean &#39;sessionService&#39; while setting bean property &#39;sessionService&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;sessionService&#39;: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalArgumentException: Invalid registry store file &#x2F;data&#x2F;erp.guanyisoft.com&#x2F;tomcat&#x2F;ecerp-web.properties, cause: Failed to create directory &#x2F;data&#x2F;erp.guanyisoft.com&#x2F;tomcat!</span><br><span class="line">	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:329) ~[spring-beans-3.2.0.RELEASE.jar:3.2.0.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:107) ~[spring-beans-3.2.0.RELEASE.jar:3.2.0.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1391) ~[spring-beans-3.2.0.RELEASE.jar:3.2.0.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1132) ~[spring-beans-3.2.0.RELEASE.jar:3.2.0.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:522) ~[spring-beans-3.2.0.RELEASE.jar:3.2.0.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:461) ~[spring-beans-3.2.0.RELEASE.jar:3.2.0.RELEASE]</span><br><span class="line">	at org.</span><br></pre></td></tr></table></figure>
<p>java报错总要看异常信息，以上主要关键的地方列在这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;nested exception is java.lang.IllegalArgumentException: Invalid registry store file &#x2F;data&#x2F;erp.guanyisoft.com&#x2F;tomcat&#x2F;ecerp-web.properties, cause: Failed to create directory &#x2F;data&#x2F;erp.guanyisoft.com&#x2F;tomcat!</span><br></pre></td></tr></table></figure>
<p>idea tomcat 在启动web应用的时候会生成一个注册dubbo服务的文件，需要指定生成路径，以前项目都是默认生成在out文件里的吧，最近，不知道什么变动，需要手工在项目配置文件application.properties 指定一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.registry.file &#x3D; &#x2F;home&#x2F;hcj&#x2F;Work&#x2F;data&#x2F;ecerp-web.properties</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 无线网卡状态异常修复</title>
    <url>/ipfs/jie-jue-linux-wu-xian-wang-qia-zhuang-tai-yi-chang/</url>
    <content><![CDATA[<p>无线网卡异常，有很多种原因造成。这里我是因为有做AP共享WIFI，本来好好的，不知道怎么实然，我手机wifi断了，再看，从PC共享的WIFI竟然挂了。<br>就这样，下班回家，准备链接无线路由，因为有换新的网，得重新链接：</p>
<pre><code>$ sudo wifi-menu -o</code></pre><p>竟然报No networks found </p>
<p>重启了问题依然存在，没办法，只能用有线先连着。<br>开始Google：No networks found<br>我一开始就找错了方向，自然是没有找到解决的方法。</p>
<p>经过这次，让我对日志的记录有了更深的认识，以前，觉得日志记录太难看得懂了，从来都是很少去看，浪费了很多时间在无用的地方，这里给自己个警戒，凡是就得先看日志信息。</p>
<p>这样，接下来，在日志里有发现有这个错误 Operation not possible due to RF-kill<br>Google一下，就找到了问题的关键，原因RF-KILL其实是一个打开和关闭无线设备的工具。 由此可以知道，这是一打开无线设备wifi的错误。<br>因为我用的arch没有安装rfkill,执行：</p>
<pre><code>$ sudo pacman -S rfkill</code></pre><p>安装好以后，为了查看当前的无限网卡的状态，执行命令rfkill list all  ——列出所有无线设备的当前状态。结果如下：<br><img data-src="/content/images/2015/07/--_2015-07-18_01-13-01.png" alt=""></p>
<p>发现 Hard blocked 和 soft blocked 之间的同步失败,具体原因可以看这里<a href="http://askubuntu.com/questions/62166/siocsifflags-operation-not-possible-due-to-rf-kill" target="_blank" rel="noopener">“SIOCSIFFLAGS: Operation not possible due to RF-kill”?</a></p>
<p>找到问题原因，我们可以使用命令使软硬设备同步:</p>
<pre><code>$ rfkill unblock wifi  </code></pre><p>用命令 rfkill list all 列出所有无线设备状态看一下结果，<br><img data-src="/content/images/2015/07/--_2015-07-18_01-24-26.png" alt=""></p>
<p>好了，无线网卡状态异常的问题修复了。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>wifi</tag>
        <tag>RF-kill</tag>
      </tags>
  </entry>
  <entry>
    <title>linux用extundelete恢复ext2、ext3、ext4下rm -rf误删除的数据</title>
    <url>/ipfs/linuxyong-extundeletehui-fu-ext2-ext3-ext4xia-rm-rfwu-shan-chu-de-shu-ju/</url>
    <content><![CDATA[<p>国外的Linux系统管理员守则中有这么一条：“慎用 rm -rf 命令，除非你知道此命令所带来的后果“</p>
<p>Linux下删除文件并不是真实的删除磁盘分区中的文件，而是将文件的inode节点中的扇区指针清除，同时释放这些数据对应的数据块，当释放的数据块被系统重新分配时，那些被删除的数据就会被覆盖，所以误删除数据后，应马上卸载文件所在的分区。<br>每个文件有inode和block组成，inode是文件系统组成的最基本单元，它保存着文件的基本属性(大小、权限、属主组等)和存放的位置信息。而block用来存储数据。类似key-value，inode就是key，block对应value，通过key查找key对应的value。类似python的字典。</p>
<h2 id="查看根目录的inode值"><a href="#查看根目录的inode值" class="headerlink" title="查看根目录的inode值"></a>查看根目录的inode值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -id &#x2F;</span><br><span class="line">2 &#x2F;</span><br></pre></td></tr></table></figure>
<p>一般”根”目录的inode值为2,一个分区挂载到一个目录下时，这个”根”目录的inode值为2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sdb2 &#x2F;mnt</span><br><span class="line">ls -id &#x2F;mnt</span><br><span class="line">2 &#x2F;mnt</span><br></pre></td></tr></table></figure>

<h2 id="安装extundelete"><a href="#安装extundelete" class="headerlink" title="安装extundelete"></a>安装extundelete</h2><h3 id="下载extundelete"><a href="#下载extundelete" class="headerlink" title="下载extundelete"></a>下载extundelete</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget   http:&#x2F;&#x2F;ncu.dl.sourceforge.net&#x2F;project&#x2F;extundelete&#x2F;extundelete&#x2F;0.2.0&#x2F;extundelete-0.2.0.tar.bz2</span><br></pre></td></tr></table></figure>
<h3 id="所需依赖包"><a href="#所需依赖包" class="headerlink" title="所需依赖包"></a>所需依赖包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install e2fsprogs e2fsprogs-libs e2fsprogs-devel</span><br></pre></td></tr></table></figure>
<h3 id="编译安装extundelte"><a href="#编译安装extundelte" class="headerlink" title="编译安装extundelte"></a>编译安装extundelte</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar jxvf extundelete-0.2.0.tar.bz2</span><br><span class="line"># cd extundelte-0.2.0</span><br><span class="line"># .&#x2F;configure</span><br><span class="line"># make; make install</span><br></pre></td></tr></table></figure>
<h2 id="用extundelete恢复文件"><a href="#用extundelete恢复文件" class="headerlink" title="用extundelete恢复文件"></a>用extundelete恢复文件</h2><h3 id="模拟数据误删除环境"><a href="#模拟数据误删除环境" class="headerlink" title="模拟数据误删除环境"></a>模拟数据误删除环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir &#x2F;data</span><br><span class="line"># mkfs.ext4 &#x2F;dev&#x2F;sdb2</span><br><span class="line"># mount &#x2F;dev&#x2F;sdb2 &#x2F;data</span><br><span class="line"># cp &#x2F;etc&#x2F;hosts &#x2F;data&#x2F;</span><br><span class="line"># mkdir &#x2F;data&#x2F;test</span><br><span class="line"># echo &quot;extundelete test&quot; &gt; &#x2F;data&#x2F;test&#x2F;geek.txt</span><br><span class="line"># md5sum hosts                           </span><br><span class="line">#获取文件校验码</span><br><span class="line">54fb6627dbaa37721048e4549db3224d  hosts</span><br><span class="line"># md5sum test&#x2F;geek.txt</span><br><span class="line">eb42e4b3f953ce00e78e11bf50652a80  test&#x2F;geek.txt</span><br><span class="line"># rm -fr &#x2F;data&#x2F;*</span><br></pre></td></tr></table></figure>
<h3 id="卸载磁盘分区"><a href="#卸载磁盘分区" class="headerlink" title="卸载磁盘分区"></a>卸载磁盘分区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount &#x2F;dev&#x2F;sdb2</span><br></pre></td></tr></table></figure>
<h3 id="查询恢复数据信息"><a href="#查询恢复数据信息" class="headerlink" title="查询恢复数据信息"></a>查询恢复数据信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete &#x2F;dev&#x2F;sdb2 --inode 2</span><br></pre></td></tr></table></figure>
<p>…..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File name                             | Inode number | Deleted status</span><br><span class="line">Directory block 8657:</span><br><span class="line">.                                          2</span><br><span class="line">..                                         2</span><br><span class="line">lost+found                                 11             Deleted</span><br><span class="line">hosts                                      12             Deleted</span><br><span class="line">test                                       130817         Deleted</span><br></pre></td></tr></table></figure>
<p>上面标记为Deleted是已经删除的文件或目录</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="开始恢复单个文件"><a href="#开始恢复单个文件" class="headerlink" title="开始恢复单个文件"></a>开始恢复单个文件</h3><p>默认恢复到当前目录下的RECOVERED_FILES目录中去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete &#x2F;dev&#x2F;sdb2 --restore-file hosts</span><br></pre></td></tr></table></figure>
<h3 id="恢复一个目录"><a href="#恢复一个目录" class="headerlink" title="恢复一个目录"></a>恢复一个目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete &#x2F;dev&#x2F;sdb2 --restore-directory test&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="全部恢复"><a href="#全部恢复" class="headerlink" title="全部恢复"></a>全部恢复</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete &#x2F;dev&#x2F;sdb2 --restore-all</span><br></pre></td></tr></table></figure>

<h2 id="检测是否恢复成功"><a href="#检测是否恢复成功" class="headerlink" title="检测是否恢复成功"></a>检测是否恢复成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># md5sum RECOVERED_FILES&#x2F;hosts                     获取文件校验码</span><br><span class="line">54fb6627dbaa37721048e4549db3224d  RECOVERED_FILES&#x2F;hosts</span><br><span class="line"># md5sum RECOVERED_FILES&#x2F;test&#x2F;geek.txt</span><br><span class="line">eb42e4b3f953ce00e78e11bf50652a80  RECOVERED_FILES&#x2F;test&#x2F;geek.txt</span><br></pre></td></tr></table></figure>
<p>校验码与之前的完全一致。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>extundelete</tag>
        <tag>fdisk</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装配置软路由</title>
    <url>/ipfs/openwrt-raspberry/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>Raspberry Pi 2 Model B Rev 1.1</li>
<li>SD卡闪盘(4G+)</li>
<li>主机我用的是ArchLinux,内核4.19.52-1-lts</li>
<li>主路由器一个TPlink</li>
<li>USB网卡</li>
<li>一条网线</li>
</ul>
<h1 id="刷openwrt固件"><a href="#刷openwrt固件" class="headerlink" title="刷openwrt固件"></a>刷openwrt固件</h1><h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>去<a href="https://www.openwrt.org" target="_blank" rel="noopener">官网</a>下载对应的安装固件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;downloads.openwrt.org&#x2F;releases&#x2F;18.06.4&#x2F;targets&#x2F;brcm2708&#x2F;bcm2709&#x2F;openwrt-18.06.4-brcm2708-bcm2709-rpi-2-ext4-factory.img.gz</span><br><span class="line">gzip -d openwrt-18.06.4-brcm2708-bcm2709-rpi-2-ext4-factory.img.gz</span><br></pre></td></tr></table></figure>
<h2 id="烧写SD卡"><a href="#烧写SD卡" class="headerlink" title="烧写SD卡"></a>烧写SD卡</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l   #列出闪盘设备名 &#x2F;dev&#x2F;mmcblk0</span><br><span class="line">sudo dd if&#x3D;openwrt-18.06.4-brcm2708-bcm2709-rpi-2-ext4-factory.img of&#x3D;&#x2F;dev&#x2F;mmcblk0</span><br></pre></td></tr></table></figure>
<h2 id="链接树莓派"><a href="#链接树莓派" class="headerlink" title="链接树莓派"></a>链接树莓派</h2><p> 配置主机IP(192.168.1.1) 网线直接连接树莓派接口 浏览器打开192.168.1.1 配置密码和ssh登陆以后，在终端里登陆<code>ssh root@192.168.1.1</code></p>
<p>修改lan口配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;config&#x2F;network</span><br><span class="line"></span><br><span class="line">config interface &#39;lan&#39;</span><br><span class="line">        option type &#39;bridge&#39;</span><br><span class="line">        option ifname &#39;eth0&#39;</span><br><span class="line">        option proto &#39;static&#39;</span><br><span class="line">        option netmask &#39;255.255.255.0&#39;</span><br><span class="line">        option ip6assign &#39;60&#39;</span><br><span class="line">        option ipaddr &#39;192.168.10.109&#39;</span><br><span class="line">        option gateway &#39;192.168.10.1&#39;</span><br><span class="line">        option broadcast &#39;255.255.255.0&#39;</span><br><span class="line">        option dns &#39;114.114.114.114&#39;</span><br></pre></td></tr></table></figure>

<p>重启路由，用网线连接主路由器就可以链接外网了。</p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>安装支持网卡的模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install kmod-rtl8192cu</span><br></pre></td></tr></table></figure>

<h3 id="修改无线网络配置"><a href="#修改无线网络配置" class="headerlink" title="修改无线网络配置"></a>修改无线网络配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;config&#x2F;wireless</span><br><span class="line"></span><br><span class="line">config wifi-iface &#39;default_radio0&#39;</span><br><span class="line">        option device &#39;radio0&#39;</span><br><span class="line">        option network &#39;lan&#39;</span><br><span class="line">        option mode &#39;ap&#39;</span><br><span class="line">        option encryption &#39;none&#39;</span><br><span class="line">        option ssid &#39;CMCCFREE&#39;</span><br></pre></td></tr></table></figure>

<h3 id="修改路由网络配置"><a href="#修改路由网络配置" class="headerlink" title="修改路由网络配置"></a>修改路由网络配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cat &#x2F;etc&#x2F;config&#x2F;network</span><br><span class="line"></span><br><span class="line">config interface &#39;loopback&#39;</span><br><span class="line">        option ifname &#39;lo&#39;</span><br><span class="line">        option proto &#39;static&#39;</span><br><span class="line">        option ipaddr &#39;127.0.0.1&#39;</span><br><span class="line">        option netmask &#39;255.0.0.0&#39;</span><br><span class="line"></span><br><span class="line">config globals &#39;globals&#39;</span><br><span class="line">        option ula_prefix &#39;fd3c:ca1e:c593::&#x2F;48&#39;</span><br><span class="line"></span><br><span class="line">config interface &#39;lan&#39;</span><br><span class="line">        option proto &#39;static&#39;</span><br><span class="line">        option netmask &#39;255.255.255.0&#39;</span><br><span class="line">        option ipaddr &#39;192.168.10.1&#39;</span><br><span class="line">        option ip6assign &#39;64&#39;</span><br><span class="line"></span><br><span class="line">config interface &#39;wan&#39;</span><br><span class="line">        option ifname &#39;eth0&#39;</span><br><span class="line">        option proto &#39;dhcp&#39;</span><br><span class="line">        option dns &#39;127.0.0.1&#39; #### 连接该 OpenWrt 路由器的所有设备发出的 DNS 请求都会由该路由器的 dnsmasq 来响应（当然，前提是设备没有手动去修改默认的 DNS 服务器 IP，而使用路由器默认提供的 DNS 服务器 IP）。</span><br><span class="line">        option peerdns &#39;0&#39; #### 忽略通告的DNS服务器地址</span><br></pre></td></tr></table></figure>

<h3 id="修改DHCP配置如下"><a href="#修改DHCP配置如下" class="headerlink" title="修改DHCP配置如下"></a>修改DHCP配置如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@OpenWrt:~# cat &#x2F;etc&#x2F;config&#x2F;dhcp</span><br><span class="line"></span><br><span class="line">config dnsmasq</span><br><span class="line">        option domainneeded &#39;1&#39;</span><br><span class="line">        option localise_queries &#39;1&#39;</span><br><span class="line">        option rebind_protection &#39;1&#39;</span><br><span class="line">        option rebind_localhost &#39;1&#39;</span><br><span class="line">        option domain &#39;lan&#39;</span><br><span class="line">        option expandhosts &#39;1&#39;</span><br><span class="line">        option authoritative &#39;1&#39;</span><br><span class="line">        option readethers &#39;1&#39;</span><br><span class="line">        option leasefile &#39;&#x2F;tmp&#x2F;dhcp.leases&#39;</span><br><span class="line">        option nonwildcard &#39;1&#39;</span><br><span class="line">        option localservice &#39;1&#39;</span><br><span class="line">        option logqueries &#39;1&#39;</span><br><span class="line">        option noresolv &#39;1&#39;</span><br><span class="line">        option local &#39;&#x2F;lan&#x2F;&#39;</span><br><span class="line">        option allservers &#39;1&#39;</span><br><span class="line">        list server &#39;114.114.114.114&#39; #### 配置DNS转发 注意，此为路由器默认查询的 DNS 服务器，你可以根据你的实际情况选择一个较快的 DNS 服务器</span><br><span class="line"></span><br><span class="line">config dhcp &#39;lan&#39;</span><br><span class="line">        option interface &#39;lan&#39;</span><br><span class="line">        option dhcpv6 &#39;server&#39;</span><br><span class="line">        option ra &#39;server&#39;</span><br><span class="line">        option ra_management &#39;1&#39;</span><br><span class="line"></span><br><span class="line">config dhcp &#39;wan&#39;</span><br><span class="line">        option interface &#39;wan&#39;</span><br><span class="line">        option ignore &#39;1&#39;</span><br></pre></td></tr></table></figure>

<h3 id="提交修改并重启"><a href="#提交修改并重启" class="headerlink" title="提交修改并重启"></a>提交修改并重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uci commit &#x2F;etc&#x2F;config&#x2F;wireless</span><br><span class="line">uci commit &#x2F;etc&#x2F;config&#x2F;network</span><br><span class="line">uci commit &#x2F;etc&#x2F;config&#x2F;dhcp</span><br><span class="line"></span><br><span class="line">## 重启路由也是一样的或者执行以下命令重启服务</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;dnsmasq restart</span><br><span class="line">&#x2F;etc&#x2F;ini.d&#x2F;network restart</span><br><span class="line">ifup wan &amp;&amp; wifi</span><br></pre></td></tr></table></figure>

<h1 id="安装SS"><a href="#安装SS" class="headerlink" title="安装SS"></a>安装SS</h1><h2 id="安装-shadowsocks-libev-相关的包"><a href="#安装-shadowsocks-libev-相关的包" class="headerlink" title="安装 shadowsocks-libev 相关的包"></a>安装 shadowsocks-libev 相关的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install shadowsocks-libev-config shadowsocks-libev-ss-local shadowsocks-libev-ss-redir shadowsocks-libev-ss-rules shadowsocks-libev-ss-tunnel luci-app-shadowsocks-libev</span><br></pre></td></tr></table></figure>

<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>进入openwrt web配置界面，选择 Service-&gt;shadowsocks-libev</p>
<p>点击 Remote Servers, 里面已经默认配置一个服务器 sss0，修改地址，端口，密码，加密方式，最重要的，将disabled的勾去掉，点击 save&amp;apply 按钮。</p>
<p>再点击 Local Instances, 点击 ss-local.cfgXXXXX (XXX为随机数字)条目对应的Disabled 按钮，将其变成 Enabled，点击 Save &amp; Apply。配置保存生效以后, ss-local.cfgXXXX 条目的Running 状态由no变为yes。这时，路由器上已经运行一个SOCKS5服务器，端口1080。设置电脑浏览器的代理服务器为路由器地址，端口1080，尝试访问谷歌，如果成功则说明ss客户端在openwrt上工作一切正常。</p>
<p>接着要测试iptables+ss-redir自动转发代理(透明代理)的功能，在Local Instances中，将ss-redir.hi 设为Enabled。再点击 Redir Rules, Disabled勾去掉，点击Destination Settings，dst default 由bypass改为 forward。点击Save&amp;Apply 使配置生效。将电脑浏览器的代理设置取消，访问谷歌，如果成功，则说明无条件透明代理设置成功。所有数据包都由路由器转发到ss服务器了。</p>
<h2 id="3-进阶配置"><a href="#3-进阶配置" class="headerlink" title="3. 进阶配置"></a>3. 进阶配置</h2><p>上面最后配置的透明代理将全部流量都转发到远端SS服务器，显然太浪费流量，而且国内的网站去国外转一圈效率也很低。因此我们需要在路由器上识别国内国外流量，区别对待。</p>
<p>1.首先将 Destination Settings中的dst forward 设为 bypass。</p>
<ol start="2">
<li>将opkg列表更新由http 改为https, http存在更新不全的情况，可能是GFW搞鬼</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg install libustream-mbedtls (如果提示找不到，opkg update 多运行几次)</span><br><span class="line">sed -i s&#x2F;http:&#x2F;https:&#x2F;g &#x2F;etc&#x2F;opkg&#x2F;distfeeds.conf</span><br><span class="line">opkg update</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装各种依赖包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg remove dnsmasq</span><br><span class="line">opkg install dnsmasq-full</span><br><span class="line">opkg install coreutils-base64 curl ca-certificates ca-bundle</span><br></pre></td></tr></table></figure>

<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><h2 id="dnsmasq服务不启动"><a href="#dnsmasq服务不启动" class="headerlink" title="dnsmasq服务不启动"></a>dnsmasq服务不启动</h2><p>最早手动添加域名到 /etc/dnsmasq.d/下的配置文件中，经过测试，发现无法解析该域名，经过排查，可能是配置文件编码格式的问题，导致了dnsmasq服务无法启动</p>
<h2 id="主机路由地址"><a href="#主机路由地址" class="headerlink" title="主机路由地址"></a>主机路由地址</h2><p>排查问题我们在主机上用<code>nslookup</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graz@graz ~ % nslookup twitter.com</span><br><span class="line">Server:		192.168.1.1</span><br><span class="line">Address:	192.168.1.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: 104.244.42.65</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: 104.244.42.1</span><br></pre></td></tr></table></figure>
<p>如上，看server项，是上上级的路由地址，这就绕过了树莓派的路由直接走上级路由查询。</p>
<p>然后，我们再看一下<code>cat /etc/resolv.conf</code><br>可以看到有多个路由地址，包括<code>192.168.10.1</code>，<code>192.168.1.1</code></p>
<p>以上，主机路由地址获取到了上上级的路由，也不知道怎么回事，(有知道的可以邮件通知我一下，谢谢大家)，只能先手动修改一下主机路由如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">nameserver 192.168.10.1 ## 这里是树莓派路由器的路由地址，一开始获取的还有上上级的路由地址如：192.168.1.1 。要把这个删掉</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后，查看日志或者安装tcpdump抓取5353端口看是否正常配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update </span><br><span class="line">opkg install tcpdump</span><br><span class="line">tcpdump -vv -i lo port 5353</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.kompaz.win/2017/03/24/OpenWRT%20Shadowsocks+GFWList%20%E6%B5%81%E9%87%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%B5%81/" target="_blank" rel="noopener">OpenWRT Shadowsocks+GFWList 流量自动分流</a></li>
<li><a href="https://medium.com/@cnnbysy/openwrt-18-06-1-%E9%85%8D%E7%BD%AE%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-30e231958c38" target="_blank" rel="noopener">openwrt 18.06.1 配置科学上网</a></li>
<li><a href="https://swsmile.info/2019/01/30/%E3%80%90Network%E3%80%91Shadowsocks%20-Shadowsocks-OpenWRT-dnsmasq-full-ipset-gfwList-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%88%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8mini%EF%BC%89%E8%87%AA%E5%8A%A8%E7%BF%BB%E5%A2%99/" target="_blank" rel="noopener">Shadowsocks + OpenWRT + dnsmasq-full + ipset + gfwList 实现路由器</a></li>
<li><a href="https://blog.ch3n2k.com/posts/xin-de-ji-yu-openwrt-lu-you-qi-de-bu-wan-quan-zi-dong-fan-qiang-fang-an.html" target="_blank" rel="noopener">新的基于OpenWrt路由器的（不完全）自动翻墙方案</a></li>
</ul>
]]></content>
      <tags>
        <tag>openwrt</tag>
        <tag>raspberry</tag>
      </tags>
  </entry>
  <entry>
    <title>Arch Linux 内核更新 修复无线模块rtl8821ce编译失败的问题</title>
    <url>/ipfs/kernel-upgrade-fix-rtl8821ce/</url>
    <content><![CDATA[<blockquote>
<p>最近更新系统，内核从4.15 更新到了 4.16.9发现原来的无线模块编译不通过，找不到头文件stdarg.h</p>
</blockquote>
<h1 id="查看无线驱动信息"><a href="#查看无线驱动信息" class="headerlink" title="查看无线驱动信息"></a>查看无线驱动信息</h1><p>通过<code>ip l</code>可以看到只有有线网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp3s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;ether 8c:16:45:3f:68:0d brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>查看无线网卡驱动，找到相应的驱动去下载就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci | grep -i &#39;newwork&#39;</span><br><span class="line"></span><br><span class="line">Network controller: Realtek Semiconductor Co., Ltd. RTL8821CE 802.11ac PCIe Wireless Network Adapter</span><br></pre></td></tr></table></figure>

<h1 id="下载无线驱动源码"><a href="#下载无线驱动源码" class="headerlink" title="下载无线驱动源码"></a>下载无线驱动源码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;endlessm&#x2F;linux</span><br></pre></td></tr></table></figure>
<p>由于这个项目特别的大，这里只需要下载drivers/net/wireless/rtl8821ce</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h2><p>这里需要修改Makefile中TopDIR变量的值为当前路径，否则会提示错误退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd drivers&#x2F;net&#x2F;wireless&#x2F;rtl8821ce</span><br><span class="line">sed -i &#39;s&#x2F;export TopDIR ?&#x3D;&#x2F;export TopDIR ?&#x3D; $(shell pwd)&#x2F;g&#39; Makefile</span><br></pre></td></tr></table></figure>
<h2 id="执行make"><a href="#执行make" class="headerlink" title="执行make"></a>执行<code>make</code></h2><p>在最新的内核版本（4.16.9-1-ARCH）下编译失败，提示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graz@graz ~&#x2F;Source&#x2F;driver_net_wireless&#x2F;rtl8821ce % make</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;make ARCH&#x3D;x86_64 CROSS_COMPILE&#x3D; -C &#x2F;lib&#x2F;modules&#x2F;4.16.9-1-ARCH&#x2F;build M&#x3D;&#x2F;home&#x2F;graz&#x2F;Source&#x2F;driver_net_wireless&#x2F;rtl8821ce  modules</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;usr&#x2F;lib&#x2F;modules&#x2F;4.16.9-1-ARCH&#x2F;build&#39;</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;graz&#x2F;Source&#x2F;driver_net_wireless&#x2F;rtl8821ce&#x2F;core&#x2F;rtw_cmd.o</span><br><span class="line">In file included from .&#x2F;include&#x2F;linux&#x2F;list.h:9,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;module.h:9,</span><br><span class="line">                 from &#x2F;home&#x2F;graz&#x2F;Source&#x2F;driver_net_wireless&#x2F;rtl8821ce&#x2F;include&#x2F;basic_types.h:81,</span><br><span class="line">                 from &#x2F;home&#x2F;graz&#x2F;Source&#x2F;driver_net_wireless&#x2F;rtl8821ce&#x2F;include&#x2F;drv_types.h:31,</span><br><span class="line">                 from &#x2F;home&#x2F;graz&#x2F;Source&#x2F;driver_net_wireless&#x2F;rtl8821ce&#x2F;core&#x2F;rtw_cmd.c:22:</span><br><span class="line">.&#x2F;include&#x2F;linux&#x2F;kernel.h:6:10: fatal error: stdarg.h: No such file or directory</span><br><span class="line"> #include &lt;stdarg.h&gt;</span><br><span class="line">          ^~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>

<p>通过<code>locate stdarg.h</code>找到头文件 “/usr/lib/gcc/x86_64-pc-linux-gnu/8.1.0/include/stdarg.h”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-pc-linux-gnu&#x2F;8.1.0&#x2F;include&#x2F;stdarg.h include&#x2F;</span><br></pre></td></tr></table></figure>

<p>软链接创建好后，就可以执行<code>make</code>编译成功</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br><span class="line">modprobe 8821ce</span><br></pre></td></tr></table></figure>
<p>最后，没有报错的话，通过<code>ip l</code> 就可以找到这个无线网卡了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp3s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;ether 8c:16:45:3f:68:0d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: wlp5s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class="line">    link&#x2F;ether 70:c9:4e:d8:6d:01 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>rtl8821ce</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus6p Root提权以及刷机攻略</title>
    <url>/ipfs/root-nexus6p-use-twrp-magisk/</url>
    <content><![CDATA[<blockquote>
<p>Android 10.0也出来一段时间了，想着给自己的手机刷一下。所以就有了这个攻略，记录一下过程。</p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>确保设备电池电量超过50%</li>
<li>备份当前的文件和数据</li>
<li>在手机上启用USB调试和OEM解锁</li>
<li>下载ADB驱动程序，安装到你的PC机里</li>
<li>去这里<a href="https://twrp.me/Devices/" target="_blank" rel="noopener">下载</a>符合nexus6p的TWRP，这里我下载了3.3.1版本的</li>
<li>去magisk官网下载最新版本应用包括manage</li>
<li>下载刷机的固件<a href="https://download.pixelexperience.org/angler" target="_blank" rel="noopener">PixelExperience 10</a></li>
</ul>
<h1 id="使用ADB和Fastboot解锁Bootloader"><a href="#使用ADB和Fastboot解锁Bootloader" class="headerlink" title="使用ADB和Fastboot解锁Bootloader"></a>使用ADB和Fastboot解锁Bootloader</h1><p>打开终端运行如下命令重启手机到fastboot模式，<a href="https://developers.google.com/android/images" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flashing unlock</span><br></pre></td></tr></table></figure>
<p>完成以后，就成功解锁了Bootloader，再次检查以启用“开发人员选项”，然后转到“开发人员选项”并启用USB调试模式OEM解锁。有时，他们在启动后会自行禁用。</p>
<h1 id="安装TWRP"><a href="#安装TWRP" class="headerlink" title="安装TWRP"></a>安装TWRP</h1><p>还是一样先进到启动模式，把TWRP镜像刷进recovery,如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash recovery twrp-3.3.1-0-angler.img</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完成上面两个准备刷机的步骤基本上就不用担心手机变砖了，下面开始刷机</p>
</blockquote>
<h1 id="刷PixelExperience-10-到Nexus6p"><a href="#刷PixelExperience-10-到Nexus6p" class="headerlink" title="刷PixelExperience 10 到Nexus6p"></a>刷PixelExperience 10 到Nexus6p</h1><p>首先确保Nexus6p没有刷过其他第三方Rom，如果刷过，要先通过官方Rom还原到指定<a href="https://developers.google.com/android/images#angler" target="_blank" rel="noopener">版本</a><br>这里我们需要下载8.1.0 (OPM7.181205.001, Dec 2018)版本，解压进入文件夹执行shell就可以还原了。当然首先还得USB链接成功。</p>
<h2 id="刷入Pixel-10固件"><a href="#刷入Pixel-10固件" class="headerlink" title="刷入Pixel 10固件"></a>刷入Pixel 10固件</h2><p>确保nexus6p是最新版本8.1.0以后，我们就可以通过TWRP刷入Pixel这个最新的固件了</p>
<p>重启手机，进入手机端的TWRP界面，点选Advanced选项，然后在手机界面里点选ADB sideload选项，然后滑动下面的滑块确认选择，等待电脑端执行adb sideload 刷机包名.zip命令</p>
<p>这里有一点要注意，下载固件的时候要把版本10的两个文件都下载了，因为最新的那版本指纹，锁屏功能有问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -x PixelExperience_angler-10.0-20191231-1607-OFFICIAL.zip -d piexl2019</span><br><span class="line">unzip -x PixelExperience_angler-10.0-20200101-0925-OFFICIAL.zip -d piexl2020</span><br><span class="line">cp piexl2019&#x2F;boot.img piexl2020</span><br><span class="line">cd piexl2020</span><br><span class="line">zip -r -v -o pixel20200101.zip .</span><br></pre></td></tr></table></figure>
<p>完成以上，生成我们要刷入的pixel20200101.zip这个固件包了，可以进入TWRP界面三清数据以后线刷就OK了<br>这里的三清指的是擦除system &amp; data &amp; cache 这三个分区，还有格式化data分区<br>最后执行以下，重启就能进入新系统了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb sideload pixel20200101.zip</span><br></pre></td></tr></table></figure>
<p>到这里，如果不需要Root手机的话就不用看下面的了</p>
<h1 id="Root提权"><a href="#Root提权" class="headerlink" title="Root提权"></a>Root提权</h1><p><a href="https://www.youtube.com/watch?v=3pxOeiIBrHI&t=582s" target="_blank" rel="noopener">参考</a><br>首先进到新系统（别忘了还是要先开启开发者选项）安装magisk manager这个app,把上一步解压出来的boot.img复制到手机里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push boot.img &#x2F;sdcard&#x2F;</span><br></pre></td></tr></table></figure>
<p>操作magisk manager安装magisk的补丁，生成magisk_patched.img<br>把补丁下载回PC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull &#x2F;sdcard&#x2F;Download&#x2F;magisk_patched.img .</span><br></pre></td></tr></table></figure>

<p>重启手机进入快速启动模式,把补丁刷入boot</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastboot flash boot magisk_patched.img</span><br></pre></td></tr></table></figure>
<p>最后重启手机，进入magisk manager检查root权限。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://forum.xda-developers.com/nexus-6p/development/rom-pixel-experience-t3970525" target="_blank" rel="noopener"> PixelExperience for Google Nexus 6P 【angler】</a></li>
<li><a href="https://forum.xda-developers.com/nexus-6p/orig-development/rom-lineageos-17-0-nexus-6p-angler-t4012099" target="_blank" rel="noopener">【ROM】【UNOFFICIAL】LineageOS 17.1 for Nexus 6P (angler)</a></li>
<li><a href="https://mikey2008.github.io/2019/12/31/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E4%B8%80%E5%8A%A05%E5%88%B7LineageOS%E5%85%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">【教程】一加5刷LineageOS全过程</a></li>
</ul>
]]></content>
      <tags>
        <tag>nexus6p</tag>
        <tag>android</tag>
        <tag>magisk</tag>
        <tag>twrp</tag>
      </tags>
  </entry>
  <entry>
    <title>php session 丢失BUG修改</title>
    <url>/ipfs/php-session-diu-shi-bugxiu-gai/</url>
    <content><![CDATA[<p>今天真是被这个问题给郁闷到了，调试了代码半天时间，终于从<a href="http://www.111cn.net/phper/php-cy/56742.htm" target="_blank" rel="noopener">http://www.111cn.net/phper/php-cy/56742.htm</a> 里找到了线索。就是存储session的目录权限不可写，或者目录空间満了写不进去就会出现这个BUG.</p>
<pre><code>$ ls -al /     
drwxr-xr-x.  12 root root 53248 Jun 15 17:14 tmp</code></pre><p>发现/tmp 目录权限不对。</p>
<p>后面，打开Thinkphp debug ,trace 页面查找到 open(‘/tmp/sess_ifoeq9834f98h4h54’,O_REIOR) promostion demoin</p>
<blockquote>
<p>总结一下， 就是遇到问题，日志才是最好的排错地方。这里记录一下，以免以后又犯错，直接去调试代码，花费了不小的功夫，还找不到原因。</p>
</blockquote>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>session</tag>
        <tag>Thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>用OPENWRT路由器抓包网络流量笔记</title>
    <url>/ipfs/openwrt-wireshark-setting/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>openwrt是一款基于linux的路由器系统，可以安装很多相关的工具包，完成像linux系统服务器可以完成的工作，比如今天我们要讲的路由器的网络数据包抓包。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>安装了openwrt的路由器，ip地址：192.168.10.1</li>
<li>要抓包流量的Android手机，ip地址：192.68.10.235</li>
<li>工作台笔记本，ip地址：192.168.10.234</li>
</ul>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><blockquote>
<p>以下介绍两种方法都可以实现路由器数据包抓取的功能</p>
</blockquote>
<p><strong><em>简单的说明<br>根据openwrt文档，所有的局域网的数据最后都是通过br-lan虚拟网卡来做转发，所以对此网卡进行监控即可<br>此命令本质是远程在路由器上执行网络监控命令，输入文本到本机的wireshark里面<br>使用wireshark作为可视化工具来查看</em></strong></p>
<h2 id="捕获与tcpdump的通信"><a href="#捕获与tcpdump的通信" class="headerlink" title="捕获与tcpdump的通信"></a>捕获与tcpdump的通信</h2><blockquote>
<p>Tcpdump可以安装在OpenWrt路由器上。因此，这种方法消除了让远程Wireshark或类似听众实时分析流量的需要。</p>
</blockquote>
<p>ssh登陆到openwrt(默认端口：22)，更新并安装tcpdump</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install tcpdump</span><br></pre></td></tr></table></figure>
<p>执行以下命令在接口（-i）上侦听并将捕获的信息存储到文件（-w），并在执行此操作时（-v）进行冗长操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -v -w pcap.cap</span><br></pre></td></tr></table></figure>
<p>生成的pcap.cap文件，我们可以传回工作台，用wireshark打开做进一步的分析</p>
<blockquote>
<p>以下是一些使用tcpdump的例子：</p>
</blockquote>
<ul>
<li><a href="https://www.rationallyparanoid.com/articles/tcpdump.html" target="_blank" rel="noopener">https://www.rationallyparanoid.com/articles/tcpdump.html</a></li>
</ul>
<h3 id="制作一键命令脚本"><a href="#制作一键命令脚本" class="headerlink" title="制作一键命令脚本"></a>制作一键命令脚本</h3><p>命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p ssh端口 -o StrictHostKeyChecking&#x3D;no ssh用户名@ssh地址 &#39;tcpdump -s 0 -U -n -w - -i br-lan not port ssh端口&#39; | wireshark -k -i -</span><br></pre></td></tr></table></figure>
<p>由于我环境配置了不用密码登陆的方式所以我们可以直接写成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh openwrt &#39;tcpdump -s 0 -U -n -w - -i br-lan not port 22&#39; | wireshark -k -i -</span><br><span class="line">ssh -p 22 -o StrictHostKeyChecking&#x3D;no root@192.168.10.1 &#39;tcpdump -s 0 -U -n -w - -i br-lan not port 22&#39; | wireshark -k -i -</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前面讲述了基本的原理和操作手段，但是缺点是每次都需要输入长串命令行和密码，可以利用linux的一些小操作技巧，简化此过程，做成一个命令工具，方便随时调用。<br>基本原理：</p>
</blockquote>
<ul>
<li>使用 sshpass 工具来做密码输入</li>
<li>使用 alias 别名来做成命令语句</li>
</ul>
<p>在工作台安装sshpass，执行以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S sshpass</span><br><span class="line">sshpass -p &#39;password&#39; ssh -p 22 -o StrictHostKeyChecking&#x3D;no root@192.168.10.1 &#39;tcpdump -s 0 -U -n -w - -i br-lan not port 22&#39; | wireshark-gtk -k -i -</span><br></pre></td></tr></table></figure>
<p>把执行语句写到<code>.bash_rc</code>就可以一条命令执行抓包分析了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias tsharkbyopenwrt&#x3D;&quot;sshpass -p &#39;password&#39; ssh -p 22 -o StrictHostKeyChecking&#x3D;no root@192.168.10.1 &#39;tcpdump -s 0 -U -n -w - -i br-lan not port 22&#39; | wireshark-gtk -k -i -&quot;</span><br></pre></td></tr></table></figure>

<h3 id="完善脚本"><a href="#完善脚本" class="headerlink" title="完善脚本"></a>完善脚本</h3><p>通过命名管道来导回数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfifo &#x2F;tmp&#x2F;fifo</span><br><span class="line">sshpass -p &#39;passwrod&#39; ssh openwrt &#39;tcpdump -s 0 -U -n -w - -i br-lan not port 22&#39; &gt; &#x2F;tmp&#x2F;fifo &amp; wireshark-gtk -k -i &#x2F;tmp&#x2F;fifo</span><br></pre></td></tr></table></figure>
<p><em>这里我配置了<code>.ssh/config</code>，所以可以直接使用<code>ssh openwrt</code>命令代替前面指定端口与用户名的方式。</em></p>
<blockquote>
<p>我们还有一个方法可以不用安装sshpass,直接使用密钥的方式来登陆路由器抓包,以上就可以写为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id openwrt</span><br><span class="line">ssh openwrt &#39;tcpdump -s 0 -U -n -w - -i br-lan not port 22&#39; &gt; &#x2F;tmp&#x2F;fifo &amp; wireshark-gtk -k -i &#x2F;tmp&#x2F;fifo</span><br></pre></td></tr></table></figure>

<h2 id="使用远程Wireshark侦听器进行分析"><a href="#使用远程Wireshark侦听器进行分析" class="headerlink" title="使用远程Wireshark侦听器进行分析"></a>使用远程Wireshark侦听器进行分析</h2><p>ssh登陆到openwrt(默认端口：22)，更新并安装iptables-mod-tee</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update </span><br><span class="line">opkg install iptables-mod-tee</span><br></pre></td></tr></table></figure>
<p>运行以下iptables命令以“在输出接口（-o）上将源IP（-s）的每个数据包的副本转发到网关IP（ - 网关）”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A POSTROUTING -t mangle -o br-lan ! -s 192.168.10.235 -j TEE --gateway 192.168.10.234</span><br></pre></td></tr></table></figure>
<p>运行以下iptables命令以“在接口（-i）上将目的IP（-d）的每个数据包的副本转发到网关IP（ - 网关）”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A PREROUTING -t mangle -i br-lan ! -d 192.168.10.235 -j TEE --gateway 192.168.10.234</span><br></pre></td></tr></table></figure>
<p>在Wireshark上开始捕获流量并应用下面的过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(ip.src &#x3D;&#x3D; 192.168.9.121) || (ip.dst &#x3D;&#x3D; 192.168.9.121)</span><br></pre></td></tr></table></figure>

<p>关于iptable规则一些有用的资源：</p>
<ul>
<li><a href="https://wiki.openwrt.org/doc/howto/netfilter" target="_blank" rel="noopener">https://wiki.openwrt.org/doc/howto/netfilter</a></li>
<li><a href="http://www.faqs.org/docs/iptables/index.html" target="_blank" rel="noopener">http://www.faqs.org/docs/iptables/index.html</a></li>
<li><a href="http://ipset.netfilter.org/iptables-extensions.man.html#lbDW" target="_blank" rel="noopener">http://ipset.netfilter.org/iptables-extensions.man.html#lbDW</a></li>
</ul>
<h2 id="安装使用CloudShark"><a href="#安装使用CloudShark" class="headerlink" title="安装使用CloudShark"></a>安装使用CloudShark</h2><p>CloudShark是一个独立的，与LEDE无关的云分析平台。它依靠cshark插件远程发送数据包进行分析。请检查您的内部规则，是否允许将网络流量发送到云平台。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install cshark luci-app-cshark</span><br></pre></td></tr></table></figure>
<p>请查看<a href="https://support.cloudshark.org/openwrt/openwrt-cloudshark.html" target="_blank" rel="noopener">Cloud Shark文档</a>以获取更多信息。</p>
<h1 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h1><p>在工作台使用wireshark-gtk的时候报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Couldn&#39;t run &#x2F;usr&#x2F;bin&#x2F;dumpcap in child process: Permission denied</span><br></pre></td></tr></table></figure>
<p>这是由于dumpcap这个的权限问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll &#x2F;usr&#x2F;bin&#x2F;dumpcap                                                                  :(</span><br><span class="line">-rwxr-xr-- 1 root wireshark 102K May 23 06:39 &#x2F;usr&#x2F;bin&#x2F;dumpcap</span><br></pre></td></tr></table></figure>
<p>只要把当前用户加入到wireshark用户组里，重启就ok了（暂时不明为什么一定要重启，反正我是重启以后才正常使用的)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG wireshark $LOGNAME</span><br><span class="line">sudo setcap cap_net_raw,cap_net_admin+eip &#x2F;usr&#x2F;bin&#x2F;dumpcap</span><br></pre></td></tr></table></figure>
<p><em>setcat对应使用getcap查看当前的方法权限</em></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ayomaonline.com/security/analyzing-network-traffic-with-openwrt/" target="_blank" rel="noopener">ANALYZING NETWORK TRAFFIC WITH OPENWRT</a></li>
<li><a href="https://openwrt.org/docs/guide-user/firewall/capture-filter-inspect-packets" target="_blank" rel="noopener">How to capture, filter and inspect packets</a></li>
<li><a href="http://www.ayomaonline.com/security/getting-started-with-openwrt-linuxfying-routers/" target="_blank" rel="noopener">GETTING STARTED WITH OPENWRT – LINUXFYING ROUTERS</a></li>
</ul>
]]></content>
      <tags>
        <tag>openwrt</tag>
        <tag>wireshark</tag>
        <tag>cloudshark</tag>
      </tags>
  </entry>
  <entry>
    <title>ss-redir 的 iptables 配置(透明代理)</title>
    <url>/ipfs/ss-redir-de-iptables-pei-zhi-tou-ming-dai-li/</url>
    <content><![CDATA[<blockquote>
<p>透明代理指对客户端透明，客户端不需要进行任何设置就使用了网管设置的代理规则<br>创建 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;ss-redir.json 本地监听 1080 运行ss-redir -v -c &#x2F;etc&#x2F;ss-redir.json</span><br></pre></td></tr></table></figure>

<h3 id="NAT表配置脚本"><a href="#NAT表配置脚本" class="headerlink" title="NAT表配置脚本"></a>NAT表配置脚本</h3><p>基本配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -N SHADOWSOCKS</span><br><span class="line"></span><br><span class="line"># 在 nat 表中创建新链</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp --dport 23596 -j RETURN</span><br><span class="line"></span><br><span class="line"># 23596 是 ss 代理服务器的端口，即远程 shadowsocks 服务器提供服务的端口，如果你有多个 ip 可用,但端口一致，就设置这个</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 123.456.789.111 -j RETURN</span><br><span class="line"># 123.456.789.111 是 ss 代理服务器的 ip, 如果你只有一个 ss服务器的 ip，却能选择不同端口,就设置此条</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 10.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 127.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 169.254.0.0&#x2F;16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 172.16.0.0&#x2F;12 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 192.168.0.0&#x2F;16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 224.0.0.0&#x2F;4 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 240.0.0.0&#x2F;4 -j RETURN</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 1080</span><br><span class="line"># 1080 是 ss-redir 的监听端口,ss-local 和 ss-redir 的监听端口不同,配置文件不同</span><br></pre></td></tr></table></figure>

<p>最后是应用上面的规则,将OUTPUT出去的tcp流量全部经过SOCKS链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#如果是在openwrt上实现透明代理的话,使用下面被注释了的规则</span><br><span class="line"></span><br><span class="line">iptables -t nat -I PREROUTING -p tcp -j SHADOWSOCKS</span><br><span class="line"># 在 PREROUTING 链前插入 SHADOWSOCKS 链,使其生效</span><br><span class="line"></span><br><span class="line">在个人电脑上使用以下配置</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS</span><br></pre></td></tr></table></figure>
<h3 id="如果要过滤国内流量可以"><a href="#如果要过滤国内流量可以" class="headerlink" title="如果要过滤国内流量可以"></a>如果要过滤国内流量可以</h3><p>列表太长了就不列出来了！</p>
<h3 id="清除自定义规则"><a href="#清除自定义规则" class="headerlink" title="清除自定义规则"></a>清除自定义规则</h3><p>清空整个链 iptables -F 链名,比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -F SHADOWSOCKS</span><br></pre></td></tr></table></figure>
<p>删除指定的用户自定义链 iptables -X 链名 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -X SHADOWSOCKS</span><br></pre></td></tr></table></figure>
<p>从所选链中删除规则 iptables -D 链名 规则详情 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -D SHADOWSOCKS -d 223.223.192.0&#x2F;255.255.240.0 -j RETURN</span><br></pre></td></tr></table></figure>


<h3 id="解决DNS污染的问题"><a href="#解决DNS污染的问题" class="headerlink" title="解决DNS污染的问题"></a>解决DNS污染的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -S archlinuxcn&#x2F;dnsmasq-china-list-git</span><br><span class="line">$ sudo dnsmasq-update-china-list 114</span><br><span class="line">####脚本如下：</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  114)</span><br><span class="line">    DNS&#x3D;114.114.114.114</span><br><span class="line">    ;;</span><br><span class="line">  ali)</span><br><span class="line">    DNS&#x3D;223.5.5.5</span><br><span class="line">    ;;</span><br><span class="line">  cnnic)</span><br><span class="line">    DNS&#x3D;1.2.4.8</span><br><span class="line">    ;;</span><br><span class="line">  baidu)</span><br><span class="line">    DNS&#x3D;180.76.76.76</span><br><span class="line">    ;;</span><br><span class="line">  google)</span><br><span class="line">    DNS&#x3D;8.8.8.8</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    DNS&#x3D;$1</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">sed -i &quot;s|^\(server.*\)&#x2F;[^&#x2F;]*$|\1&#x2F;$DNS|&quot; &#x2F;etc&#x2F;dnsmasq.d&#x2F;accelerated-domains.china.conf</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>iptables</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>保持文件原有排序去除重复行</title>
    <url>/ipfs/bao-chi-wen-jian-yuan-lai-pai-xu-qu-chu-zhong-fu-xing/</url>
    <content><![CDATA[<p>通常如果我们想获取一个文件里不重复的行的时候，我们可以直接通过 sort -u 命令，先把文件排序，然后去掉连续的重复行就行。</p>
<p>可是，如果我们去掉重复行之后，还想保留文件原有的顺序，该怎么办呢？虽然 Linux 下有个看上去似乎很有用的命令叫 uniq，但事实上 uniq 命令仅仅只对连续的重复行有效。譬如我们有这样一个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat file3</span><br><span class="line">AAAA</span><br><span class="line">FFFF</span><br><span class="line">BBBB</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">AAAA</span><br><span class="line">FFFF</span><br><span class="line">DDDD</span><br></pre></td></tr></table></figure>
<p>如果不排序，直接使用 uniq 命令是没有用的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uniq file3</span><br><span class="line">AAAA</span><br><span class="line">FFFF</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">AAAA</span><br><span class="line">FFFF</span><br><span class="line">DDDD</span><br></pre></td></tr></table></figure>
<p>使用 sort -u 的话，我们就丢失了文件原有的行的顺序了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -u file3</span><br><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">DDDD</span><br><span class="line">FFFF</span><br></pre></td></tr></table></figure>
<p>sort 和 uniq 一起用，和 sort -u 效果是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort file3 | uniq</span><br><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">DDDD</span><br><span class="line">FFFF</span><br></pre></td></tr></table></figure>
<p>一个终极的解决方案是使用 awk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39; !x[$0]++&#39; file3</span><br><span class="line">AAAA</span><br><span class="line">FFFF</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">DDDD</span><br></pre></td></tr></table></figure>
<p>简要解释一下，awk 的基本执行流程是，对文件的每一行，做一个指定的逻辑判断，如果逻辑判断成立，则执行指定的命令；如果逻辑判断不成立，则直接跳过这一行。</p>
<p>我们这里写的 awk 命令是 !x[$0]++，意思是，首先创建一个 map 叫 x，然后用当前行的全文 $0 作为 map 的 key，到 map 中查找相应的 value，如果没找到，则整个表达式的值为真，可以执行之后的语句；如果找到了，则表达式的值为假，跳过这一行。由于表达式之后有 ++，因此如果某个 key 找不到对应的 value，该 ++ 操作会先把对应的 value 设成 0，然后再自增成 1，这样下次再遇到重复的行的时候，对应的 key 就能找到一个非 0 的 value 了。</p>
<p>我们前面说过，awk 的流程是先判断表达式，表达式为真的时候就执行语句，可是我们前面写的这个 awk 命令里只有表达式，没有语句，那我们执行什么呢？原来，当语句被省略的时候，awk 就执行默认的语句，即打印整个完整的当前行。就这样，我们通过这个非常简短的 awk 命令实现了去除重复行并保留原有文件顺序的功能。</p>
<p><a href="http://edyfox.codecarver.org/html/bash_unique_lines_no_sorting.html" target="_blank" rel="noopener">引用</a></p>
<p>本文部分翻译来自 <a href="http://www.unixcl.com/" target="_blank" rel="noopener">Jadu Saikia 的博客</a>，这个博客上有很多非常有用的小技巧，有空可以多看看。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>sed</tag>
        <tag>bash</tag>
        <tag>awk</tag>
        <tag>sort</tag>
        <tag>uniq</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 服务端配置</title>
    <url>/ipfs/ssh-fu-wu-duan-pei-zhi/</url>
    <content><![CDATA[<blockquote>
<p>最近，在使用U盘安装gentoo配置sshd服务端碰到了问题，记录一下ssh服务端的配置文件。</p>
</blockquote>
<h2 id="关于-SSH-Server-的整体设定，包含使用的-port-啦，以及使用的密码演算方式"><a href="#关于-SSH-Server-的整体设定，包含使用的-port-啦，以及使用的密码演算方式" class="headerlink" title="关于 SSH Server 的整体设定，包含使用的 port 啦，以及使用的密码演算方式"></a>关于 SSH Server 的整体设定，包含使用的 port 啦，以及使用的密码演算方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Port 22　　　　　　　　　　# SSH 预设使用 22 这个 port，您也可以使用多的 port ！</span><br><span class="line">　　　　　　　　　　　　　 # 亦即重复使用 port 这个设定项目即可！</span><br><span class="line">Protocol 2,1　　　　　　　 # 选择的 SSH 协议版本，可以是 1 也可以是 2 ，</span><br><span class="line">　　　　　　　　　　　　　 # 如果要同时支持两者，就必须要使用 2,1 这个分隔了！</span><br><span class="line">#ListenAddress 0.0.0.0　　 # 监听的主机适配卡！举个例子来说，如果您有两个 IP，</span><br><span class="line">　　　　　　　　　　　　　 # 分别是 192.168.0.100 及 192.168.2.20 ，那么只想要</span><br><span class="line">　　　　　　　　　　　　　 # 开放 192.168.0.100 时，就可以写如同下面的样式：</span><br><span class="line">ListenAddress 192.168.0.100          # 只监听来自 192.168.0.100 这个 IP 的SSH联机。</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 如果不使用设定的话，则预设所有接口均接受 SSH</span><br><span class="line">PidFile &#x2F;var&#x2F;run&#x2F;sshd.pid　　　　　　# 可以放置 SSHD 这个 PID 的档案！左列为默认值</span><br><span class="line">LoginGraceTime 600　　　　 # 当使用者连上 SSH server 之后，会出现输入密码的画面，</span><br><span class="line">　　　　　　　　　　　　　 # 在该画面中，在多久时间内没有成功连上 SSH server ，</span><br><span class="line">　　　　　　　　　　　　　 # 就断线！时间为秒！</span><br><span class="line">Compression yes　　　　　　# 是否可以使用压缩指令？当然可以啰！</span><br></pre></td></tr></table></figure>
<p>　</p>
<h2 id="说明主机的-Private-Key-放置的档案，预设使用下面的档案即可！"><a href="#说明主机的-Private-Key-放置的档案，预设使用下面的档案即可！" class="headerlink" title="说明主机的 Private Key 放置的档案，预设使用下面的档案即可！"></a>说明主机的 Private Key 放置的档案，预设使用下面的档案即可！</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key　　　　# SSH version 1 使用的私钥</span><br><span class="line">HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key　　# SSH version 2 使用的 RSA 私钥</span><br><span class="line">HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_key　　# SSH version 2 使用的 DSA 私钥</span><br></pre></td></tr></table></figure>
<h3 id="关于-version-1-的一些设定！"><a href="#关于-version-1-的一些设定！" class="headerlink" title="关于 version 1 的一些设定！"></a>关于 version 1 的一些设定！</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyRegenerationInterval 3600　 　　　# 由前面联机的说明可以知道， version 1 会使用 </span><br><span class="line">　　　　　　　　　　　　　　　　　　 # server 的 Public Key ，那么如果这个 Public </span><br><span class="line">　　　　　　　　　　　　　　　　　　 # Key 被偷的话，岂不完蛋？所以需要每隔一段时间</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 来重新建立一次！这里的时间为秒！</span><br><span class="line">ServerKeyBits 768 　　　　　　　　　 # 没错！这个就是 Server key 的长度！</span><br></pre></td></tr></table></figure>
<h2 id="关于登录文件的讯息数据放置与-daemon-的名称！"><a href="#关于登录文件的讯息数据放置与-daemon-的名称！" class="headerlink" title="关于登录文件的讯息数据放置与 daemon 的名称！"></a>关于登录文件的讯息数据放置与 daemon 的名称！</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyslogFacility AUTH　　　　　　　　　# 当有人使用 SSH 登入系统的时候，SSH会记录资</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 讯，这个信息要记录在什么 daemon name 底下？</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 预设是以 AUTH 来设定的，即是 &#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 里面！什么？忘记了！回到 Linux 基础去翻一下</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 其它可用的 daemon name 为：DAEMON,USER,AUTH,</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,</span><br><span class="line">LogLevel INFO　　　　　　　　　　　　# 登录记录的等级！嘿嘿！任何讯息！</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 同样的，忘记了就回去参考！</span><br></pre></td></tr></table></figure>
<h2 id="安全设定项目！极重要！"><a href="#安全设定项目！极重要！" class="headerlink" title="安全设定项目！极重要！"></a>安全设定项目！极重要！</h2><h3 id="登入设定部分"><a href="#登入设定部分" class="headerlink" title="登入设定部分"></a>登入设定部分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin no　　 　　# 是否允许 root 登入！最新版本的sshd配置默认是不允许使用root登陆的，如果要使用root登陆，要把no 改为 yes 。</span><br><span class="line">UserLogin no　　　　　　　 # 在 SSH 底下本来就不接受 login 这个程序的登入！</span><br><span class="line">StrictModes yes　　　　　　# 当使用者的 host key 改变之后，Server 就不接受联机，</span><br><span class="line">　　　　　　　　　　　　　 # 可以抵挡部分的木马程序！</span><br><span class="line">RSAAuthentication yes　　 # 是否使用纯的 RSA 认证！？仅针对 version 1 ！</span><br><span class="line">PubkeyAuthentication yes　 # 是否允许 Public Key ？当然允许啦！只有 version 2</span><br><span class="line">AuthorizedKeysFile      .ssh&#x2F;authorized_keys</span><br><span class="line">　　　　　　　　　　　　　 # 上面这个在设定若要使用不需要密码登入的账号时，那么那个</span><br><span class="line">　　　　　　　　　　　　　 # 账号的存放档案所在档名！</span><br></pre></td></tr></table></figure>
<h3 id="认证部分"><a href="#认证部分" class="headerlink" title="认证部分"></a>认证部分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RhostsAuthentication no　　# 本机系统不止使用 .rhosts ，因为仅使用 .rhosts 太</span><br><span class="line">　　　　　　　　　　　　　 # 不安全了，所以这里一定要设定为 no ！</span><br><span class="line">IgnoreRhosts yes　　　　　 # 是否取消使用 ~&#x2F;.ssh&#x2F;.rhosts 来做为认证！当然是！</span><br><span class="line">RhostsRSAAuthentication no # 这个选项是专门给 version 1 用的，使用 rhosts 档案在</span><br><span class="line">　　　　　　　　　　　　　 # &#x2F;etc&#x2F;hosts.equiv配合 RSA 演算方式来进行认证！不要使用</span><br><span class="line">HostbasedAuthentication no # 这个项目与上面的项目类似，不过是给 version 2 使用的！</span><br><span class="line">IgnoreUserKnownHosts no　　# 是否忽略家目录内的 ~&#x2F;.ssh&#x2F;known_hosts 这个档案所记录</span><br><span class="line">　　　　　　　　　　　　　 # 的主机内容？当然不要忽略，所以这里就是 no 啦！</span><br><span class="line">PasswordAuthentication yes # 密码验证当然是需要的！所以这里写 yes 啰！</span><br><span class="line">PermitEmptyPasswords no　　# 若上面那一项如果设定为 yes 的话，这一项就最好设定</span><br><span class="line">　　　　　　　　　　　　　 # 为 no ，这个项目在是否允许以空的密码登入！当然不许！</span><br><span class="line">ChallengeResponseAuthentication yes  # 挑战任何的密码认证！所以，任何 login.conf </span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 规定的认证方式，均可适用！</span><br><span class="line">#PAMAuthenticationViaKbdInt yes      # 是否启用其它的 PAM 模块！启用这个模块将会</span><br><span class="line">　　　　　　　　　　　　　　　　　　 # 导致 PasswordAuthentication 设定失效！</span><br></pre></td></tr></table></figure>
<p>　</p>
<h3 id="与-Kerberos-有关的参数设定！因为我们没有-Kerberos-主机，所以底下不用设定！"><a href="#与-Kerberos-有关的参数设定！因为我们没有-Kerberos-主机，所以底下不用设定！" class="headerlink" title="与 Kerberos 有关的参数设定！因为我们没有 Kerberos 主机，所以底下不用设定！"></a>与 Kerberos 有关的参数设定！因为我们没有 Kerberos 主机，所以底下不用设定！</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#KerberosAuthentication no</span><br><span class="line">#KerberosOrLocalPasswd yes</span><br><span class="line">#KerberosTicketCleanup yes</span><br><span class="line">#KerberosTgtPassing no</span><br></pre></td></tr></table></figure>

<h3 id="底下是有关在-X-Window-底下使用的相关设定！"><a href="#底下是有关在-X-Window-底下使用的相关设定！" class="headerlink" title="底下是有关在 X-Window 底下使用的相关设定！"></a>底下是有关在 X-Window 底下使用的相关设定！</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X11Forwarding yes</span><br><span class="line">#X11DisplayOffset 10</span><br><span class="line">#X11UseLocalhost yes</span><br></pre></td></tr></table></figure>
<h3 id="登入后的项目："><a href="#登入后的项目：" class="headerlink" title="登入后的项目："></a>登入后的项目：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PrintMotd no              # 登入后是否显示出一些信息呢？例如上次登入的时间、地点等</span><br><span class="line">　　　　　　　　　　　　　# 等，预设是 yes ，但是，如果为了安全，可以考虑改为 no ！</span><br><span class="line">PrintLastLog yes　　　　　# 显示上次登入的信息！可以啊！预设也是 yes ！</span><br><span class="line">KeepAlive yes　　　　　　 # 一般而言，如果设定这项目的话，那么 SSH Server 会传送</span><br><span class="line">　　　　　　　　　　　　　# KeepAlive 的讯息给 Client 端，以确保两者的联机正常！</span><br><span class="line">　　　　　　　　　　　　　# 在这个情况下，任何一端死掉后， SSH 可以立刻知道！而不会</span><br><span class="line">　　　　　　　　　　　　　# 有僵尸程序的发生！</span><br><span class="line">UsePrivilegeSeparation yes # 使用者的权限设定项目！就设定为 yes 吧！</span><br><span class="line">MaxStartups 10　　　　　　# 同时允许几个尚未登入的联机画面？当我们连上 SSH ，</span><br><span class="line">　　　　　　　　　　　　　# 但是尚未输入密码时，这个时候就是我们所谓的联机画面啦！</span><br><span class="line">　　　　　　　　　　　　　# 在这个联机画面中，为了保护主机，所以需要设定最大值，</span><br><span class="line">　　　　　　　　　　　　　# 预设最多十个联机画面，而已经建立联机的不计算在这十个当中</span><br></pre></td></tr></table></figure>
<h3 id="关于使用者抵挡的设定项目："><a href="#关于使用者抵挡的设定项目：" class="headerlink" title="关于使用者抵挡的设定项目："></a>关于使用者抵挡的设定项目：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DenyUsers *　　　　　　　 # 设定受抵挡的使用者名称，如果是全部的使用者，那就是全部</span><br><span class="line">　　　　　　　　　　　　　# 挡吧！若是部分使用者，可以将该账号填入！例如下列！</span><br><span class="line">DenyUsers test</span><br><span class="line">DenyGroups test　　　　　 # 与 DenyUsers 相同！仅抵挡几个群组而已！</span><br></pre></td></tr></table></figure>
<h2 id="关于-SFTP-服务的设定项目！"><a href="#关于-SFTP-服务的设定项目！" class="headerlink" title="关于 SFTP 服务的设定项目！"></a>关于 SFTP 服务的设定项目！</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subsystem       sftp    &#x2F;usr&#x2F;lib&#x2F;ssh&#x2F;sftp-server</span><br></pre></td></tr></table></figure>
<p>　<br>基本上，在您的系统中，『除非有必要，否则请不要更改 /etc/ssh/sshd_config 这个档案的设定值！』因为预设的情况下通常都是最严密的 SSH 保护了，因此，可以不需要更动他！上面的说明仅是在让大家了解每个细项的一些基本内容而已！需要注意的是最后一项，如果您不愿意开放 SFTP 的话，将最后一行批注掉即可！
　</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>sshd</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 node.js ghost 相关总结</title>
    <url>/ipfs/an-zhuang-ghostxiang-guan-zong-jie/</url>
    <content><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote>
<p>安装node.js 下载最新node.js 编译安装需要一段时间。</p>
</blockquote>
<pre><code>$ wget http://nodejs.org/dist/node-latest.tar.gz
$ tar -xzf node-latest.tar.gz
$ cd node-v
$ ./configure
$ make
$ sudo make install</code></pre><h2 id="安装Ghost"><a href="#安装Ghost" class="headerlink" title="安装Ghost"></a>安装Ghost</h2><h3 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h3><p> <code>$ yum install gcc-c++</code></p>
<h3 id="ghost下载，安装"><a href="#ghost下载，安装" class="headerlink" title="ghost下载，安装"></a>ghost下载，安装</h3><pre><code>$ sudo mkdir -p /data/www/
$ cd /data/www/
$ wget https://ghost.org/zip/ghost-latest.zip
$ unzip -d ghost ghost-latest.zip
$ cd /var/www/ghost
$ sudo npm install --production</code></pre><p><em>安装完成后用 npm start 命令启动开发者模式下的 Ghost，用于检查有没有安装成功。 成功了，Ghost会运行在本地局域网内 127.0.0.1:2368。如果是在电脑上安装的，用浏览器访问此地址即可预览 Ghost。</em>   </p>
<h2 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h2><blockquote>
<p>安装强大的进程守护程序“PM2”保证应用在开机以后自动启动</p>
</blockquote>
<p>进入到/data/www/ghost，执行命令安装PM2：<br><code>$ sudo npm install pm2 -g</code></p>
<p>设置环境变量为“production”生产模式，“index.js”是程序启动的入口。最后给这个PM2的进程命名为”ghost” 执行下面的命令：<br><code>$ NODE_ENV=production pm2 start index.js --name &quot;ghost&quot;</code><br>设置开机自动运行网站：<br><code>$ pm2 startup centos
 $ pm2 save</code><br><em>可以执行 pm2 help 查看帮助。</em></p>
<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><blockquote>
<p>配置 Nginx 的反向代理：新建一个 Nginx 代理配置文件,并将代理指向到本地的Ghost端口:</p>
</blockquote>
<pre><code>$ sudo vim /etc/nginx/conf.d/ghost.conf`  
server {
     listen 80;
     server_name My-Ghost-Blog.com;
     location / {
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   Host      $http_host;
        proxy_pass         http://127.0.0.1:2368;
    }
}    </code></pre><p>重新启动 Nginx 服务器.<br><code>$ sudo service nginx restart</code></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote>
<p>修改服务器时间，这样新增的文章才能显示正常的本地时间 。</p>
</blockquote>
<pre><code>$ sudo yun install -y ntp
$ sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ghost</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>导出CSV文件，对长数字字符会自动显示科学计数解决方法</title>
    <url>/ipfs/phpdao-chu-csvwen-jian-dui-chang-shu-zi-zi-fu-hui-zi-dong-xian-shi-ke-xue-ji-shu-jie-jue-fang-fa/</url>
    <content><![CDATA[<p>今天做csv导出遇到订单号太长导致导出来用EXCEL打开显示为科学计数了，最后几位直接显示为0。但是用文本方式打开订单号是正常的，这说明一定是与EXcel有关系。<br>GOOGLE了一下，找到EXCEL相关介绍：</p>
<blockquote>
<p>Excel显示数字时，如果数字大于12位，它会自动转化为科学计数法；如果数字大于15位，它不仅用于科学技术费表示，还会只保留高15位，其他位都变0。</p>
</blockquote>
<pre><code>$oid = &quot;\t&quot;.$val[&apos;oid&apos;];</code></pre><p>如果是phpexcel导出的话，把”\t”换成” “即可。</p>
]]></content>
      <tags>
        <tag>csv</tag>
        <tag>excel</tag>
        <tag>phpexcel</tag>
      </tags>
  </entry>
  <entry>
    <title>安装配置Arch linux 相关</title>
    <url>/ipfs/an-zhuang-pei-zhi-arch-linux-xiang-guan/</url>
    <content><![CDATA[<h2 id="安装-linux-lts-软件包"><a href="#安装-linux-lts-软件包" class="headerlink" title="安装 linux-lts 软件包"></a>安装 linux-lts 软件包</h2><p><em>小贴士: 强烈推荐安装linux-lts作为备用内核，因为默认安装的linux内核比较新，容易与其它软件发生冲突</em></p>
<blockquote>
<p>linux-lts 是 Arch 官方提供的基于 Linux kernel 3.0 的长期支持内核。内核上游开发者针对此版本提供了长期支持，包括安全补丁和功能 backports。适用于需要长期支持的服务器环境用户，也可以将此内核作为新内核升级的后备内核。</p>
</blockquote>
<p><code>$ sudo pacman -S linux-lts</code>   </p>
<h2 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h2><p>需要编辑 GRUB2 或 LILO 的启动加载项。<br>以 GRUB2 为例：<br>为了编辑/更新启动加载项，需要安装os-prober.<br>安装后,再执行<br><code>$ sudo grub-mkconfig -o /boot/grub/grub.cfg</code></p>
]]></content>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装Gentoo Linux</title>
    <url>/ipfs/shu-mei-pai-an-zhuang-gentoo-linux/</url>
    <content><![CDATA[<h2 id="Gentoo介绍"><a href="#Gentoo介绍" class="headerlink" title="Gentoo介绍"></a>Gentoo介绍</h2><h3 id="Gentoo的历史"><a href="#Gentoo的历史" class="headerlink" title="Gentoo的历史"></a>Gentoo的历史</h3><pre><code>Gentoo Linux （原来被称为 Enoch Linux ) 是在1999年由Daniel Robbins 和一些开发人员开发的。目标就是创建一个没有预编译的二进制文件的Linux发行版并根据所在的硬件平台进行调整。中间因为Gentoo 缺少关键项目，没有自己的包管理系统，后面Robbins 受到FreeBSD包管理系统的启发，开发出了自己的包管理系统，被称为是portage。
Gentoo没有二进制组件，它的包树中只包含源代码，这使它成为可以移植到其他架构上的理想的操作系统。当然，它的不足之处就是需要漫长的安装时间和大量的人工参与。不过，这不就是我们学习Linux的目的嘛。</code></pre><h3 id="Gentoo与其他发行版的异同"><a href="#Gentoo与其他发行版的异同" class="headerlink" title="Gentoo与其他发行版的异同"></a>Gentoo与其他发行版的异同</h3><pre><code>Gentoo安装和大多数流行的Linux发行版很多不同的地方。虽然有自启动光盘，但是没有安装程序。安装Gentoo时，所有事情都是通过命令行手动操作的。没有配置向导也没有GUI工具。不过，它有一个非常有用的安装指南（安装使用手册）。
与其他发行版相比，Gentoo的另外一个不同点在于它没有发行版本。Gentoo是一个元发行版。元发行版指的是它会一直更新下去。使用元发行版的好处在于你可以随时更新到最新的版本程序。缺点就是你将得到非常复杂的包版本，这个版本没有经过彻底的测试，这点与Arch（另一个Linux的发行版本）是一样的。
Gentoo的处理包的方式是一大不同点。大多数发行版使用二进制包的形式来发布包。Gentoo中发布软件包的系统被称为portage。Gentoo的开发人员是受到FreeBSD的ports collection的启发，在port collection 中只有源代码和包含构建源代码的方法的小文件会发布给终端用户。这被称为源代码发布。Gentoo的portage系统是由一组文件组成的，这个文件被称为ebuild，必要的补丁文件是由Gentoo社区创建。Ebuild文件是由一个被称为emerge的工具来读取。
这个文件仅仅运行标准的./configure、make和make install 工具。这意味着你想要运行在Gentoo系统中的每一个应用程序都需要从源代码进行编译。Gentoo的一切都是从源代码进行编译的，因此，这个发行版要负责GCC工具链中的代码修复工作，包括那些改进GCC的性能优化。源代码的发布除了给Linux社区整体带来益处，也为终端用户带来了巨大的好处。当你在Gentoo中安装一个包是，你将可以通过选项来指定哪些模块被安装，哪些不需要安装，这个用来标记的方法就是use。use标记在构建的配置阶段使用，它们可以设置你想要编译应用程序的哪些部分，这样可以为你提供一个快速简洁的轻量级系统。不过，当你发现一些应用程序需要依赖你前面剔出的功能时，那么你就得需要花费更多的时间重新编译程序才能使用这些功能。- -</code></pre><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>我们是在树莓派上安装Gentoo，所以这里准备一个全新的SD卡，至少要有4GB。<br>拿到SD卡以后，首先我们为SD卡创建分区。==这里，要提醒一下，读卡器上有一个开关可以控制SD卡的读写性。如果，开关按了也没用，把卡拿出来，插拔多几次，主要是有的读卡器接触点不好，我就是遇到这个问题，卡了很长时间。==</p>
<ul>
<li>引导分区，fat32格式</li>
<li>根分区，EXT4格式或者其他的Linux文件系统格式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line">Disk &#x2F;dev&#x2F;sda：298.1 GiB，320072933376 字节，625142448 个扇区</span><br><span class="line">单元：扇区 &#x2F; 1 * 512 &#x3D; 512 字节</span><br><span class="line">扇区大小(逻辑&#x2F;物理)：512 字节 &#x2F; 512 字节</span><br><span class="line">I&#x2F;O 大小(最小&#x2F;最佳)：512 字节 &#x2F; 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x86258625</span><br><span class="line"></span><br><span class="line">设备       启动    起点    末尾    扇区 大小 Id 类型</span><br><span class="line">&#x2F;dev&#x2F;sda1  *           63  62926604  62926542    30G  7 HPFS&#x2F;NTFS&#x2F;exFAT</span><br><span class="line">&#x2F;dev&#x2F;sda2        62926605 625137344 562210740 268.1G  f W95 扩展 (LBA)</span><br><span class="line">&#x2F;dev&#x2F;sda5       272658432 272863231    204800   100M 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sda6       272865280 281253887   8388608     4G 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sda7       281255936 616800255 335544320   160G 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sda8       616802304 620996607   4194304     2G 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sda9        62928896 188758015 125829120    60G  7 HPFS&#x2F;NTFS&#x2F;exFAT</span><br><span class="line">&#x2F;dev&#x2F;sda10      188760064 209731583  20971520    10G 83 Linux</span><br><span class="line"></span><br><span class="line">分区表记录没有按磁盘顺序。</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sdb：14.9 GiB，15931539456 字节，31116288 个扇区</span><br><span class="line">单元：扇区 &#x2F; 1 * 512 &#x3D; 512 字节</span><br><span class="line">扇区大小(逻辑&#x2F;物理)：512 字节 &#x2F; 512 字节</span><br><span class="line">I&#x2F;O 大小(最小&#x2F;最佳)：512 字节 &#x2F; 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x00000000</span><br><span class="line"></span><br><span class="line">设备       启动 起点   末尾   扇区 大小 Id 类型</span><br><span class="line">&#x2F;dev&#x2F;sdb1        2048 31116287 31114240 14.9G  c W95 FAT32 (LBA)</span><br><span class="line"></span><br><span class="line">$ fdisk &#x2F;dev&#x2F;sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.27)。</span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb：14.9 GiB，15931539456 字节，31116288 个扇区</span><br><span class="line">单元：扇区 &#x2F; 1 * 512 &#x3D; 512 字节</span><br><span class="line">扇区大小(逻辑&#x2F;物理)：512 字节 &#x2F; 512 字节</span><br><span class="line">I&#x2F;O 大小(最小&#x2F;最佳)：512 字节 &#x2F; 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line"></span><br><span class="line">磁盘标识符：0x00000000</span><br><span class="line"></span><br><span class="line">设备       启动 起点   末尾   扇区 大小 Id 类型</span><br><span class="line">&#x2F;dev&#x2F;sdb1        2048 31116287 31114240 14.9G  c W95 FAT32 (LBA)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：d</span><br><span class="line">已选择分区 1</span><br><span class="line">分区 1 已删除。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">分区类型</span><br><span class="line">   p   主分区 (0个主分区，0个扩展分区，4空闲)</span><br><span class="line">   e   扩展分区 (逻辑分区容器)</span><br><span class="line">选择 (默认 p)：p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">第一个扇区 (2048-31116287，默认 2048)：</span><br><span class="line">上个扇区，+sectors 或 +size&#123;K,M,G,T,P&#125; (2048-31116287，默认 31116287)：+100M</span><br><span class="line"></span><br><span class="line">创建了一个新分区 1，类型为“Linux”，大小为 100 MiB。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">分区类型</span><br><span class="line">   p   主分区 (1个主分区，0个扩展分区，3空闲)</span><br><span class="line">   e   扩展分区 (逻辑分区容器)</span><br><span class="line">选择 (默认 p)：p</span><br><span class="line">分区号 (2-4，默认 2)：</span><br><span class="line">第一个扇区 (206848-31116287，默认 206848)：</span><br><span class="line">上个扇区，+sectors 或 +size&#123;K,M,G,T,P&#125; (206848-31116287，默认 31116287)：</span><br><span class="line"></span><br><span class="line">创建了一个新分区 2，类型为“Linux”，大小为 14.8 GiB。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb：14.9 GiB，15931539456 字节，31116288 个扇区</span><br><span class="line">单元：扇区 &#x2F; 1 * 512 &#x3D; 512 字节</span><br><span class="line">扇区大小(逻辑&#x2F;物理)：512 字节 &#x2F; 512 字节</span><br><span class="line">I&#x2F;O 大小(最小&#x2F;最佳)：512 字节 &#x2F; 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x00000000</span><br><span class="line"></span><br><span class="line">设备       启动 起点   末尾   扇区 大小 Id 类型</span><br><span class="line">&#x2F;dev&#x2F;sdb1         2048   206847   204800  100M 83 Linux</span><br><span class="line">&#x2F;dev&#x2F;sdb2       206848 31116287 30909440 14.8G 83 Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：t</span><br><span class="line">分区号 (1,2，默认 2)：1</span><br><span class="line">分区类型(输入 L 列出所有类型)：c</span><br><span class="line"></span><br><span class="line">已将分区“Linux”的类型更改为“W95 FAT32 (LBA)”。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb：14.9 GiB，15931539456 字节，31116288 个扇区</span><br><span class="line">单元：扇区 &#x2F; 1 * 512 &#x3D; 512 字节</span><br><span class="line">扇区大小(逻辑&#x2F;物理)：512 字节 &#x2F; 512 字节</span><br><span class="line">I&#x2F;O 大小(最小&#x2F;最佳)：512 字节 &#x2F; 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x00000000</span><br><span class="line"></span><br><span class="line">设备       启动 起点   末尾   扇区 大小 Id 类型</span><br><span class="line">&#x2F;dev&#x2F;sdb1         2048   206847   204800  100M  c W95 FAT32 (LBA)</span><br><span class="line">&#x2F;dev&#x2F;sdb2       206848 31116287 30909440 14.8G 83 Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">分区表已调整。</span><br><span class="line">将调用 ioctl() 来重新读分区表。</span><br><span class="line">正在同步磁盘。</span><br></pre></td></tr></table></figure>
<p>接下来，将分区按照它们自己的文件系统格式进行格式化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkfs &#x2F;dev&#x2F;sdb1</span><br><span class="line">mke2fs 1.42.12 (29-Aug-2014)</span><br><span class="line">&#x2F;dev&#x2F;sdb1 contains a ext2 file system</span><br><span class="line">	last mounted on &#x2F;mnt&#x2F;cdrom&#x2F;armv7 on Thu Sep 24 19:40:44 2015</span><br><span class="line">无论如何也要继续? (y,n) y</span><br><span class="line">Creating filesystem with 102400 1k blocks and 25688 inodes</span><br><span class="line">Filesystem UUID: 256e4119-5d49-4303-9ca2-a28638838ce6</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">	8193, 24577, 40961, 57345, 73729</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成                            </span><br><span class="line">正在写入inode表: 完成                            </span><br><span class="line">Writing superblocks and filesystem accounting information: 完成 </span><br><span class="line"></span><br><span class="line">$ mkfs.ext4 &#x2F;dev&#x2F;sdb2</span><br><span class="line">mke2fs 1.42.12 (29-Aug-2014)</span><br><span class="line">Creating filesystem with 3863680 4k blocks and 966656 inodes</span><br><span class="line">Filesystem UUID: a0a95364-389a-4c4d-b63e-e1e61ed4b6c3</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成                            </span><br><span class="line">正在写入inode表: 完成                            </span><br><span class="line">Creating journal (32768 blocks): 完成</span><br><span class="line">Writing superblocks and filesystem accounting information: 完成</span><br></pre></td></tr></table></figure>
<p>现在，我们已经创建好了两个可以使用的文件系统。然后，我们把相应分区挂载到/mnt 目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p &#x2F;mnt&#x2F;raspberry&#x2F; </span><br><span class="line">$ mount &#x2F;dev&#x2F;sdb2 &#x2F;mnt&#x2F;raspberry  #### 首先挂载根分区</span><br><span class="line">$ mkdir -p &#x2F;mnt&#x2F;raspberry&#x2F;boot &amp;&amp; mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;raspberry&#x2F;boot ### 再挂载引导分区到根分区目录里的boot下。</span><br></pre></td></tr></table></figure>
<p>这个引导分区和其他的树莓派引导分区类似。它包含基金会提供的固件、命令行参数、配置文件和内核。创建引导文件系统的第一步是从基金会的GitHub网站上获取固件文件：<br><a href="https://github.com/raspberrypi/firmware/tree/master/boot" target="_blank" rel="noopener">https://github.com/raspberrypi/firmware/tree/master/boot</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;mnt&#x2F;raspberry&#x2F;boot</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;firmware&#x2F;tree&#x2F;master&#x2F;boot&#x2F;bootcode.bin</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;firmware&#x2F;tree&#x2F;master&#x2F;boot&#x2F;start.elf</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;firmware&#x2F;tree&#x2F;master&#x2F;boot&#x2F;fixup.dat</span><br></pre></td></tr></table></figure>
<p>分别下载这三个文件就可以了。接下来，需要创建cmdline.txt 和 config.txt 两个文件。<br>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat cmdline.txt</span><br><span class="line">root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 rootdelay&#x3D;2</span><br><span class="line">$ cat config.txt</span><br><span class="line">gpu_mem&#x3D;32</span><br><span class="line"></span><br><span class="line">######完成以上步骤，用ls -l 看一下引导分区现在的文件。</span><br><span class="line">$ ls -l</span><br><span class="line">总用量 104</span><br><span class="line">-rw-r--r-- 1 root root 29026 9月  24 22:54 bootcode.bin</span><br><span class="line">-rw-r--r-- 1 root root    32 9月  24 22:59 cmdline.txt</span><br><span class="line">-rw-r--r-- 1 root root    11 9月  24 23:00 config.txt</span><br><span class="line">-rw-r--r-- 1 root root 29219 9月  24 22:56 fixup.dat</span><br><span class="line">drwx------ 2 root root 12288 9月  24 22:33 lost+found</span><br><span class="line">-rw-r--r-- 1 root root 29221 9月  24 22:56 start.elf</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载系统包"><a href="#下载系统包" class="headerlink" title="下载系统包"></a>下载系统包</h3><p><a href="http://distfiles.gentoo.org/releases/arm/autobuilds/current-stage3-armv7a_hardfp/" target="_blank" rel="noopener">http://distfiles.gentoo.org/releases/arm/autobuilds/current-stage3-armv7a_hardfp/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;Downloads&#x2F;</span><br><span class="line">$ wget http:&#x2F;&#x2F;distfiles.gentoo.org&#x2F;releases&#x2F;arm&#x2F;autobuilds&#x2F;current-stage3-armv7a_hardfp&#x2F;stage3-armv7a_hardfp-20150730.tar.bz2</span><br><span class="line">$ tar xfj ~&#x2F;Downloads&#x2F;stage3-armv7a_hardfp-20150730.tar.bz2 -C &#x2F;mnt&#x2F;raspberry   ### -C 指定解压的目录。解压需要一些时间，完成以后，看上去如下：</span><br><span class="line">$ ls -al</span><br><span class="line">总用量 89</span><br><span class="line">drwxr-xr-x 20 root root  4096 7月  30 13:50 .</span><br><span class="line">drwxr-xr-x  4 root root  4096 9月  24 22:38 ..</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 21:22 bin</span><br><span class="line">drwxr-xr-x  3 root root  1024 7月  30 13:50 boot</span><br><span class="line">drwxr-xr-x  3 root root  4096 7月  30 13:50 dev</span><br><span class="line">drwxr-xr-x 31 root root  4096 7月  30 21:31 etc</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 13:50 home</span><br><span class="line">drwxr-xr-x 10 root root  4096 7月  30 21:27 lib</span><br><span class="line">drwx------  2 root root 16384 9月  24 22:33 lost+found</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 13:50 media</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 13:50 mnt</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 13:50 opt</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 13:18 proc</span><br><span class="line">drwx------  2 root root  4096 7月  30 13:50 root</span><br><span class="line">drwxr-xr-x  3 root root  4096 7月  30 21:22 run</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 21:31 sbin</span><br><span class="line">drwxr-xr-x  2 root root  4096 7月  30 13:50 sys</span><br><span class="line">drwxrwxrwt  2 root root  4096 7月  30 21:31 tmp</span><br><span class="line">drwxr-xr-x 11 root root  4096 7月  30 21:31 usr</span><br><span class="line">drwxr-xr-x  9 root root  4096 7月  30 13:50 var</span><br></pre></td></tr></table></figure>
<p>到这里，相信大家都很熟悉这个目录了。</p>
<h3 id="配置系统文件"><a href="#配置系统文件" class="headerlink" title="配置系统文件"></a>配置系统文件</h3><p>第一步就是配置fstab，因为这是系统引导完成以后最先需要挂载好文件系统。==这里千万要注意修改的是 /mnt/raspberry/etc/fstab ==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat etc&#x2F;fstab </span><br><span class="line"># &lt;fs&gt;			&lt;mountpoint&gt;	&lt;type&gt;		&lt;opts&gt;		&lt;dump&#x2F;pass&gt;</span><br><span class="line"># NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.</span><br><span class="line">&#x2F;dev&#x2F;mmcblk0p1		&#x2F;boot   ext2		noauto,noatime	1 2</span><br><span class="line">&#x2F;dev&#x2F;mmcblk0p2		&#x2F;		ext4		noatime  		0 1</span><br></pre></td></tr></table></figure>
<p>不要使用/dev/sdX设置的引用 。因为SD卡在树莓派上被视为/dev/mmcdlk0 。因为无法chroot到新的构建环境中，所以需要手动设置一些东西。首先，为Gentoo系统设置一个新的root用户密码。如下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl passwd -1</span><br><span class="line">Password: </span><br><span class="line">Verifying - Password: </span><br><span class="line">$1$ZoQIFaY4$3Re0RSS0qu6nds3wvqlRf1</span><br></pre></td></tr></table></figure>
<p>以上，最后一行就是我们的encrypted密码，把它放到/etc/shadow文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat etc&#x2F;shadow | grep root</span><br><span class="line">root:$1$ZoQIFaY4$3Re0RSS0qu6nds3wvqlRf1:10770:0:::::</span><br></pre></td></tr></table></figure>
<h3 id="配置-portage"><a href="#配置-portage" class="headerlink" title="配置 portage"></a>配置 portage</h3><p>到目前为止，已经完成了所有的系统配置。但是，这还不是最终的系统，现在我们必须解压当前的portage集合。这样，才能在系统引导时，构建应用程序。下载，我们到以下地址去下载portage包。<br><a href="http://distfiles.gentoo.org/releases/snapshots/current/portage-lastest.tar.bz2" target="_blank" rel="noopener">http://distfiles.gentoo.org/releases/snapshots/current/portage-lastest.tar.bz2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;Downloads&#x2F;</span><br><span class="line">$ wget http:&#x2F;&#x2F;distfiles.gentoo.org&#x2F;releases&#x2F;snapshots&#x2F;current&#x2F;portage-latest.tar.bz2</span><br><span class="line">$ tar xjvpf ~&#x2F;Downloads&#x2F;portage-latest.tar.bz2 -C &#x2F;mnt&#x2F;raspberry&#x2F;usr</span><br></pre></td></tr></table></figure>
<h2 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h2><p>构造一个最小的 Linux 系统，<br>==主要分为两步：第一步是构建一个宿主系统无关的新工具链（编译器、汇编器、链接器、库和一些有用的工具）。第二步则是使用该工具链构建其它的基础工具。==<br>这里说的工具链就是说的交叉编译环境。</p>
<h3 id="下载系统内核"><a href="#下载系统内核" class="headerlink" title="下载系统内核"></a>下载系统内核</h3><p>到了这一步以后，我们需要为新的Gentoo系统构建一个内核。为了完成这一步，需要有相关配置交叉编译环境基础知识。还需要内核源码,这里我们使用树莓派官方内核源码，因为这将包含所有已经打好的树莓派的补丁。到GitHub上clone一份内核源码或者下载zip包，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;linux</span><br><span class="line">$ cd linux</span><br></pre></td></tr></table></figure>
<h3 id="为什么要使用交叉编译环境"><a href="#为什么要使用交叉编译环境" class="headerlink" title="为什么要使用交叉编译环境"></a>为什么要使用交叉编译环境</h3><p>交叉编译是在你的宿主系统上编译不同机器类型的应用程序。因为，树莓派使用的ARM架构与宿主机系统x86机器类型不同，只有使用相同的CPU机器类型才能使用chroot引导新系统。所以，这里就得用到交叉编译环境，在宿主系统上编译出ARM架构的树莓派。 在开始之前，希望大家可以先看一下<a href="http://linuxfromscratch.org/" target="_blank" rel="noopener">《Linux 从零开始》</a> 。</p>
<h3 id="crosstool-NG"><a href="#crosstool-NG" class="headerlink" title="crosstool-NG"></a>crosstool-NG</h3><p>暂时写到这里，以后再补充。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>Gentoo</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
</search>
